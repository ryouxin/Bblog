<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>java io nio面试题</title>
      <link href="/2019/12/11/java%20io%20nio%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/12/11/java%20io%20nio%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>一 Java NIO 概览<br>主要内容:</p><p>NIO简介:<br>Java NIO 是 java 1.4, 之后新出的一套IO接口NIO中的N可以理解为Non-blocking，不单纯是New。</p><p>NIO的特性/NIO与IO区别:</p><p>1)IO是面向流的，NIO是面向缓冲区的；<br>2)IO流是阻塞的，NIO流是不阻塞的;<br>3)NIO有选择器，而IO没有。</p><p>读数据和写数据方式:<br>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。<br>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</p><p>NIO核心组件简单介绍<br>Channels<br>Buffers<br>Selectors</p><p>二 Java NIO 之 Buffer(缓冲区)<br>主要内容:<br>Buffer(缓冲区)介绍:</p><p>Java NIO Buffers用于和NIO Channel交互。 我们从Channel中读取数据到buffers里，从Buffer把数据写入到Channels；<br>Buffer本质上就是一块内存区；<br>一个Buffer有三个属性是必须掌握的，分别是：capacity容量、position位置、limit限制。</p><p>Buffer的常见方法</p><p>Buffer clear()<br>Buffer flip()<br>Buffer rewind()<br>Buffer position(int newPosition)</p><p>Buffer的使用方式/方法介绍:</p><p>分配缓冲区（Allocating a Buffer）:</p><p>ByteBuffer buf = ByteBuffer.allocate(28);//以ByteBuffer为例子</p><p>写入数据到缓冲区（Writing Data to a Buffer）</p><p>写数据到Buffer有两种方法：<br>1.从Channel中写数据到Buffer<br>int bytesRead = inChannel.read(buf); //read into buffer.<br>2.通过put写数据：<br>buf.put(127);</p><p>Buffer常用方法测试<br>说实话，NIO编程真的难，通过后面这个测试例子，你可能才能勉强理解前面说的Buffer方法的作用。</p><p>三 Java NIO 之 Channel（通道）<br>主要内容:</p><p>Channel（通道）介绍</p><p>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。<br>NIO Channel通道和流的区别：</p><p>FileChannel的使用<br>SocketChannel和ServerSocketChannel的使用<br>️DatagramChannel的使用<br>Scatter / Gather</p><p>Scatter: 从一个Channel读取的信息分散到N个缓冲区中(Buufer).<br>Gather: 将N个Buffer里面内容按照顺序发送到一个Channel.</p><p>通道之间的数据传输</p><p>在Java NIO中如果一个channel是FileChannel类型的，那么他可以直接把数据传输到另一个channel。<br>transferFrom() :transferFrom方法把数据从通道源传输到FileChannel<br>transferTo() :transferTo方法把FileChannel数据传输到另一个channel</p><p>四 Java NIO之Selector（选择器）<br>主要内容:</p><p>Selector（选择器）介绍</p><p>Selector 一般称 为选择器 ，当然你也可以翻译为 多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。<br>使用Selector的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。</p><p>Selector（选择器）的使用方法介绍</p><p>Selector的创建</p><p>Selector selector = Selector.open();</p><p>注册Channel到Selector(Channel必须是非阻塞的)</p><p>channel.configureBlocking(false);<br>SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</p><p>SelectionKey介绍<br>一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p><p>从Selector中选择channel(Selecting Channels via a Selector)<br>选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中.</p><p>停止选择的方法<br>wakeup()方法 和close()方法。</p><p>模板代码<br>有了模板代码我们在编写程序时，大多数时间都是在模板代码中添加相应的业务代码。</p><p>客户端与服务端简单交互实例</p><p>五  Java NIO之拥抱Path和Files<br>主要内容<br>一 文件I/O基石：Path：</p><p>创建一个Path<br>File和Path之间的转换，File和URI之间的转换<br>获取Path的相关信息<br>移除Path中的冗余项</p><p>二 拥抱Files类：</p><p>Files.exists() 检测文件路径是否存在<br>Files.createFile() 创建文件<br>Files.createDirectories()和Files.createDirectory()创建文件夹<br>Files.delete()方法 可以删除一个文件或目录<br>Files.copy()方法可以吧一个文件从一个地址复制到另一个位置<br>获取文件属性<br>遍历一个文件夹<br>Files.walkFileTree()遍历整个目录</p><p>六  NIO学习总结以及NIO新特性介绍</p><p>内存映射：</p><p>这个功能主要是为了提高大文件的读写速度而设计的。内存映射文件(memory-mappedfile)能让你创建和修改那些大到无法读入内存的文件。有了内存映射文件，你就可以认为文件已经全部读进了内存，然后把它当成一个非常大的数组来访问了。将文件的一段区域映射到内存中，比传统的文件处理速度要快很多。内存映射文件它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快了。<br>七 Java NIO AsynchronousFileChannel异步文件通<br>Java7中新增了AsynchronousFileChannel作为nio的一部分。AsynchronousFileChannel使得数据可以进行异步读写。</p><ol><li><p>什么是IO流？<br>它是一种数据的流从源头流到目的地。比如文件拷贝，输入流和输出流都包括了。输入流从文件中读取数据存储到进程(process)中，输出流从进程中读取数据然后写入到目标文件。</p></li><li><p>字节流和字符流的区别。<br>字节流在JDK1.0中就被引进了，用于操作包含ASCII字符的文件。JAVA也支持其他的字符如Unicode，为了读取包含Unicode字符的文件，JAVA语言设计者在JDK1.1中引入了字符流。ASCII作为Unicode的子集，对于英语字符的文件，可以可以使用字节流也可以使用字符流。</p></li></ol><p>3.Java中流类的超类主要由那些？<br>java.io.InputStream<br>java.io.OutputStream<br>java.io.Reader<br>java.io.Writer</p><ol start="4"><li><p>FileInputStream和FileOutputStream是什么？<br>这是在拷贝文件操作的时候，经常用到的两个类。在处理小文件的时候，它们性能表现还不错，在大文件的时候，最好使用BufferedInputStream (或 BufferedReader) 和 BufferedOutputStream (或 BufferedWriter)</p></li><li><p>字节流和字符流，你更喜欢使用拿一个？<br>个人来说，更喜欢使用字符流，因为他们更新一些。许多在字符流中存在的特性，字节流中不存在。比如使用BufferedReader而不是BufferedInputStreams或DataInputStream，使用newLine()方法来读取下一行，但是在字节流中我们需要做额外的操作。</p></li></ol><p>6.System.out.println()是什么？<br>println是PrintStream的一个方法。out是一个静态PrintStream类型的成员变量，System是一个java.lang包中的类，用于和底层的操作系统进行交互。</p><p>7.什么是Filter流？<br>Filter Stream是一种IO流主要作用是用来对存在的流增加一些额外的功能，像给目标文件增加源文件中不存在的行数，或者增加拷贝的性能。</p><ol start="8"><li>有哪些可用的Filter流？<br>在java.io包中主要由4个可用的filter Stream。两个字节filter stream，两个字符filter stream. 分别是FilterInputStream, FilterOutputStream, FilterReader and FilterWriter.这些类是抽象类，不能被实例化的。<pre><code>有些Filter流的子类:</code></pre>LineNumberInputStream 给目标文件增加行号<br>DataInputStream 有些特殊的方法如readInt(), readDouble()和readLine() 等可以读取一个 int, double和一个string一次性的,<br>BufferedInputStream 增加性能<br>PushbackInputStream 推送要求的字节到系统中</li></ol><p>9.SequenceInputStream的作用？<br>这个类的作用是将多个输入流合并成一个输入流，通过SequenceInputStream类包装后形成新的一个总的输入流。在拷贝多个文件到一个目标文件的时候是非常有用的。可用使用很少的代码实现</p><p>10.说说PrintStream和PrintWriter<br>他们两个的功能相同，但是属于不同的分类。字节流和字符流。他们都有println()方法。</p><ol start="11"><li>在文件拷贝的时候，那一种流可用提升更多的性能？<br>在字节流的时候，使用BufferedInputStream和BufferedOutputStream。<br>在字符流的时候，使用BufferedReader 和 BufferedWriter</li></ol><p>12 .说说管道流(Piped Stream)</p><p>有四种管道流， PipedInputStream, PipedOutputStream, PipedReader 和 PipedWriter.在多个线程或进程中传递数据的时候管道流非常有用。</p><p>13.说说File类<br>它不属于 IO流，也不是用于文件操作的，它主要用于知道一个文件的属性，读写权限，大小等信息。注意：Java7中文件IO发生了很大的变化，专门引入了很多新的类来取代原来的基于java.io.File的文件IO操作方式。详情阅读下面的文章：</p><p>Java NIO之拥抱Path和Files</p><ol start="14"><li>说说RandomAccessFile?<br>它在java.io包中是一个特殊的类，既不是输入流也不是输出流，它两者都可以做到。他是Object的直接子类。通常来说，一个流只有一个功能，要么读，要么写。但是RandomAccessFile既可以读文件，也可以写文件。 DataInputStream 和 DataOutStream有的方法，在RandomAccessFile中都存在。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java反射总结</title>
      <link href="/2019/12/10/java%E5%8F%8D%E5%B0%84%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/10/java%E5%8F%8D%E5%B0%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>什么是反射？<br>反射就是动态加载对象，并对对象进行剖析。在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能成为Java反射机制。<br>反射的基本操作<br>创建一个类，用于演示反射的基本操作，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package fs;</span><br><span class="line">public class Student &#123;</span><br><span class="line">private long id;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public long getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setId(long id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>获取类中的所有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">Method[] methods = clz.getMethods();</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">System.out.println(&quot;方法名：&quot; + method.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;fs.Student&quot;)：初始化指定的类</span><br><span class="line">clz.getMethods()：获取类中所有的方法(包括其继承类的方法)</span><br></pre></td></tr></table></figure><p>如果只需要获取加载类中的方法，不要父类的方法，可以使用下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = clz.getDeclaredMethods();</span><br></pre></td></tr></table></figure><br>Method是方法类，可以获取方法相关的信息，除了我们上面的方法名称，我们还可以获取其他的一些信息，比如：</p><p>方法返回类型：method.getReturnType().getName()<br>方法修饰符：Modifier.toString(method.getModifiers())<br>方法参数信息： method.getParameters()<br>方法上的注解： method.getAnnotations()<br>等等…….</p><p>操作方法<br>除了可以获取Class中方法的信息，还可以通过反射来调用方法，接下来看看怎么调用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">Student stu = (Student) clz.newInstance();</span><br><span class="line">System.out.println(stu.getName());</span><br><span class="line">Method method = clz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">method.invoke(stu, &quot;猿天地&quot;);</span><br><span class="line">System.out.println(stu.getName());</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>通过class的newInstance()方法构造一个Student对象，然后调用getName()方法，这个时候输出的是null,然后通过方法名获取到setName方法，通过invoke调用方法，传入参数，然后调用getName()方法可以看到输出的就是我们设置的值“猿天地”。<br>获取类中的所有属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">Field[] fields = clz.getFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">System.out.println(&quot;属性名：&quot; + field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>clz.getFields()只能获取public的属性，包括父类的。<br>如果需要获取自己声明的各种字段，包括public，protected，private得用clz.getDeclaredFields()<br>Field是属性类，可以获取属性相关的信息，比如：</p><p>属性类型：field.getType().getName()<br>属性修饰符：Modifier.toString(field.getModifiers())<br>属性上的注解： field.getAnnotations()<br>等等…….</p><p>操作属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">Student stu = (Student) clz.newInstance();</span><br><span class="line">Field field = clz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">System.out.println(field.get(stu));</span><br><span class="line">field.set(stu, &quot;猿天地&quot;);</span><br><span class="line">System.out.println(field.get(stu));</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>通过clz.getDeclaredField(“name”);获取name属性，调用get方法获取属性的值，第一次肯定是没有值的，然后调用set方法设置值，最后再次获取就有值了，在get之前有field.setAccessible(true);这个代码，如果不加的话就会报下面的错误信息：<br>Class fs.Test can not access a member of class fs.Student with modifiers “private”<br>setAccessible(true);以取消Java的权限控制检查，让我们在用反射时可以访问访问私有变量<br>反射的优缺点？<br>优点</p><p>反射提高了程序的灵活性和扩展性,在底层框架中用的比较多，业务层面的开发过程中尽量少用。</p><p>缺点</p><p>性能不好<br>反射是一种解释操作,用于字段和方法接入时要远慢于直接代码，下面通过2段简单的代码来比较下执行的时间就可以体现出性能的问题</p><p>直接创建对象，调用方法设置值，然后获取值，时间在300ms左右<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">Student stu = new Student();</span><br><span class="line">stu.setName(&quot;猿天地&quot;);</span><br><span class="line">System.out.println(stu.getName());</span><br><span class="line">&#125;</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br></pre></td></tr></table></figure><br>利用反射来实现上面的功能，时间在500ms左右，我是在我本机测试的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">Student stu = (Student) clz.newInstance();</span><br><span class="line">Method method = clz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">method.invoke(stu, &quot;猿天地&quot;);</span><br><span class="line">System.out.println(stu.getName());</span><br><span class="line">&#125;</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br></pre></td></tr></table></figure></p><p>程序逻辑有影响</p><p>使用反射操作会模糊化程序的内部逻辑，从代码的维护角度来讲，我们更希望在源码中看到程序的逻辑，反射相当于绕过了源码的方式,因此会带来维护难度比较大的问题。<br>反射的使用场景有哪些？</p><p>实现RPC框架<br>实现ORM框架<br>拷贝属性值（BeanUtils.copyProperties）<br>……</p><p>实现RPC框架<br>RPC是远程过程调用的简称，广泛应用在大规模分布式应用中。提到RPC框架在我脑海里第一闪现的就是Dubbo,远程过程调用的实现原理简单无非就是当客户端调用的时候通过动态代理向服务提供方发送调用的信息（Netty通信），服务提供方收到后根据客户端需要调用的方法，调用本地方法，拿到结果组装返回。这里就涉及到动态方法的调用，反射也就可以排上用场了。<br>至于Dubbo中是怎么动态调用的我就不太清楚啦，没去研究过Dubbo的源码哈，我临时看了下，找到了2个相关的类JdkProxyFactory和JavassistProxyFactory。<br>JdkProxyFactory就是用的method.invoke(proxy, arguments);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class JdkProxyFactory extends AbstractProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object doInvoke(T proxy, String methodName,</span><br><span class="line">                                      Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">                                      Object[] arguments) throws Throwable &#123;</span><br><span class="line">                Method method = proxy.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">                return method.invoke(proxy, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavassistProxyFactory是用的Javassist框架来实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JavassistProxyFactory extends AbstractProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">        // TODO Wrapper cannot handle this scenario correctly: the classname contains &apos;$&apos;</span><br><span class="line">        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&apos;$&apos;) &lt; 0 ? proxy.getClass() : type);</span><br><span class="line">        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object doInvoke(T proxy, String methodName,</span><br><span class="line">                                      Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">                                      Object[] arguments) throws Throwable &#123;</span><br><span class="line">                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现ORM框架<br>关于ORM的概念本文就不做过多的介绍了，主要给大家介绍下如何用反射实现ORM的核心功能，我们以保持操作来进行讲解，也就是定义一个与数据库表对应的实体类，写一个save方法，传入我们实体类就可以将这个对象中的属性值存储到数据库中，变成一条数据。<br>还是以上面的Student来作为与表对应的实体类，下面我们看如何实现save方法中的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void save(Object data, Class&lt;?&gt; entityClass) throws Exception &#123;</span><br><span class="line">String sql = &quot;insert into &#123;0&#125;(&#123;1&#125;) values(&#123;2&#125;)&quot;;</span><br><span class="line">String tableName = entityClass.getSimpleName();</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; fs = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; values = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Field[] fields = entityClass.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">names.add(field.getName());</span><br><span class="line">fs.add(&quot;?&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">values.add(field.get(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String fieldStr = names.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">String valueStr = fs.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">System.err.println(MessageFormat.format(sql, tableName, fieldStr, valueStr));</span><br><span class="line">values.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Student stu = new Student();</span><br><span class="line">stu.setId(1);</span><br><span class="line">stu.setName(&quot;猿天地&quot;);</span><br><span class="line">save(stu, Student.class);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行main方法，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into Student(id,name) values(?,?)</span><br></pre></td></tr></table></figure><br>当然我上面只是最简单的代码，考虑也没那么全面，为的只是让大家熟悉反射的使用方式和场景，接下来我们再配合注解做一个小小的优化，注解不熟的同学可以参考我的这篇文章：《注解面试题-请了解下》<br>优化2点，定义一个TableName注解，用于描述表的信息，上面我们是直接用的类名作为表名，实际使用中很有可能表名是stu_info这样的 ，还有就是定义一个Field用于描述字段的信息，原理同上。<br>定义TableName注解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line">/**</span><br><span class="line"> * 表名</span><br><span class="line"> * @author yinjihuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface TableName &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 表名</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">定义Field注解：</span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line">/**</span><br><span class="line"> * 字段名</span><br><span class="line"> * @author yinjihuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123; ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE &#125;)</span><br><span class="line">public @interface Field &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 字段名称</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>修改实体类，增加注解的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@TableName(&quot;stu_info&quot;)</span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">private long id;</span><br><span class="line"></span><br><span class="line">@Field(&quot;stu_name&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public long getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setId(long id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>save方法中就需要考虑到有注解的情况，修改代码，增加获取注解中值的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void save(Object data, Class&lt;?&gt; entityClass) throws Exception &#123;</span><br><span class="line">String sql = &quot;insert into &#123;0&#125;(&#123;1&#125;) values(&#123;2&#125;)&quot;;</span><br><span class="line">String tableName = entityClass.getSimpleName();</span><br><span class="line">if (entityClass.isAnnotationPresent(TableName.class)) &#123;</span><br><span class="line">tableName = entityClass.getAnnotation(TableName.class).value();</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; fs = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; values = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Field[] fields = entityClass.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">String fieldName = field.getName();</span><br><span class="line">if (field.isAnnotationPresent(fs.Field.class)) &#123;</span><br><span class="line">fieldName = field.getAnnotation(fs.Field.class).value();</span><br><span class="line">&#125;</span><br><span class="line">names.add(fieldName);</span><br><span class="line">fs.add(&quot;?&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">values.add(field.get(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String fieldStr = names.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">String valueStr = fs.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">System.err.println(MessageFormat.format(sql, tableName, fieldStr, valueStr));</span><br><span class="line">values.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通上面的修改，如果有注解的情况下以注解中的值为主，没有的话就用Class中的。<br>执行main方法，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into stu_info(id,stu_name) values(?,?)</span><br></pre></td></tr></table></figure></p><p>更完整的反射实现的ORM可以参考我的框架：<a href="https://github.com/yinjihuan/smjdbctemplate" target="_blank" rel="noopener">https://github.com/yinjihuan/smjdbctemplate</a><br>拷贝属性值（BeanUtils.copyProperties）<br>在开发过程中，我们会遇到各种bean之间的转换，比如用ORM框架查询出来的数据，对应的bean,需要转换成Dto返回给调用方，这个时候就需要进行bean的转换了，下面通过简单的伪代码来讲解下：<br>Student stu = dao.get();<br>StudentDto dto = new StudentDto();<br>dto.setName(stu.getName());<br>dto.setXXX(stu.getXXX());<br>dto.set……<br>return dto;<br>如果属性多的话，光写set方法就要写很多行，有没有优雅的方式呢？<br>这个时候我们可以用Spring中的BeanUtils.copyProperties来实现上面的需求，只需要一行代码即可，关于BeanUtils.copyProperties的详细使用不做过多讲解：<br>Student stu = dao.get();<br>StudentDto dto = new StudentDto();<br>BeanUtils.copyProperties(stu, dto);<br>这个功能就是反射的功劳了，我们可以通过源码来验证下是否是通过反射来实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private static void copyProperties(Object source, Object target, Class&lt;?&gt; editable, String... ignoreProperties)</span><br><span class="line">throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">Assert.notNull(source, &quot;Source must not be null&quot;);</span><br><span class="line">Assert.notNull(target, &quot;Target must not be null&quot;);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; actualEditable = target.getClass();</span><br><span class="line">if (editable != null) &#123;</span><br><span class="line">if (!editable.isInstance(target)) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Target class [&quot; + target.getClass().getName() +</span><br><span class="line">&quot;] not assignable to Editable class [&quot; + editable.getName() + &quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">actualEditable = editable;</span><br><span class="line">&#125;</span><br><span class="line">PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);</span><br><span class="line">List&lt;String&gt; ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null);</span><br><span class="line"></span><br><span class="line">for (PropertyDescriptor targetPd : targetPds) &#123;</span><br><span class="line">Method writeMethod = targetPd.getWriteMethod();</span><br><span class="line">if (writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) &#123;</span><br><span class="line">PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());</span><br><span class="line">if (sourcePd != null) &#123;</span><br><span class="line">Method readMethod = sourcePd.getReadMethod();</span><br><span class="line">if (readMethod != null &amp;&amp;</span><br><span class="line">ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">readMethod.setAccessible(true);</span><br><span class="line">&#125;</span><br><span class="line">Object value = readMethod.invoke(source);</span><br><span class="line">if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">writeMethod.setAccessible(true);</span><br><span class="line">&#125;</span><br><span class="line">writeMethod.invoke(target, value);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new FatalBeanException(</span><br><span class="line">&quot;Could not copy property &apos;&quot; + targetPd.getName() + &quot;&apos; from source to target&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码不做过多解释，我们看最关键的2行代码，第一行是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object value = readMethod.invoke(source);</span><br></pre></td></tr></table></figure><br>通过调用读的方法将source中的值读取出来<br>第二行关键的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeMethod.invoke(target, value);</span><br></pre></td></tr></table></figure><br>通过调用写的方法进行复制到target中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java运算符及运算符的优先级</title>
      <link href="/2019/12/10/Java%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2019/12/10/Java%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>Java语言中提供了很多运算符来操作变量，现总结以下七种：<br>1、赋值运算符<br>2、算术运算符<br>3、关系运算符<br>4、逻辑运算符<br>5、位运算符<br>6、三目运算符<br>7、instanceof运算符</p><p>一、赋值运算符<br>赋值符号 “ = “<br>语法：变量名 = 表达式；<br>可以和算术运算符结合成复合赋值运算符，例如” += “、” -= “、” <em>= “、” /= “、” %= “<br>示例：”int a = 8”、” b += 18”、” m </em>= 5”</p><p>二、算术运算符</p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>加法运算</td><td>2+3</td><td>5</td></tr><tr><td>-</td><td>减法运算</td><td>5-2</td><td>3</td></tr><tr><td>*</td><td>乘法运算</td><td>2*3</td><td>6</td></tr><tr><td>/</td><td>除法运算</td><td>8/3</td><td>2</td></tr><tr><td>%</td><td>取余运算</td><td>5%3</td><td>2</td></tr><tr><td>++</td><td>自增运算</td><td>i=2; 　j=i++</td><td>i=3; 　j=2</td></tr><tr><td>–</td><td>自减运算</td><td>i=2; 　j=i–</td><td>i=1; 　j=2</td></tr></tbody></table><p>符号 “ + “、” - “、” * “、” / “、” % “、” ++ “、” – “<br>几点注意：</p><p>1、除法运算，两个操作数是整型的，结果也会是整型的，舍弃掉小数部分；如果有一个数是浮点数，结果将自动转型为浮点型<br>2、取余运算，两个操作数是整型的，结果也会是整型的，如果有一个数是浮点数，结果将自动转型为浮点型<br>3、自增自减运算，a++ 相当于 a = a + 1, a++ 是先运用在计算，++a 先计算在运用</p><p>三、关系运算符</p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>==</td><td>等于</td><td>2==3</td><td>false</td></tr><tr><td>!=</td><td>不等于</td><td>5!=2</td><td>true</td></tr><tr><td>&lt;</td><td>小于</td><td>2&lt;3</td><td>true</td></tr><tr><td>&gt;</td><td>大于</td><td>8&gt;3</td><td>true</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>5&lt;=3</td><td>false</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>5&gt;=3</td><td>true</td></tr></tbody></table><p>几点注意：</p><p>“ = “是赋值运算，” == “是等于运算<br>“ &gt; “、” &lt; “、” &gt;= “、” &lt;= “只支持数值类型的比较，” == “、” != “支持所有数据类型的比较<br>关系表达式的运算结果是布尔值<br>四、逻辑运算符</p><table><thead><tr><th>运算符</th><th>含义</th><th>运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>逻辑与</td><td>两个操作数都是true，结果才是true；左边取值无论真假，右边都会运算</td></tr><tr><td>&#124;</td><td>逻辑或</td><td>两个操作数一个是true，结果就是true；左边取值无论真假，右边都会运算</td></tr><tr><td>^</td><td>逻辑异或</td><td>两个操作相同，结果是false；两个操作不相同，结果是true</td></tr><tr><td>!</td><td>逻辑非</td><td>操作数是true，结果是false；操作数是false，结果是true</td></tr><tr><td>&amp;&amp;</td><td>短路与</td><td>两个操作数都是true，结果才是true；左边取值是false，右边不会运算</td></tr><tr><td>&#124;&#124;</td><td>短路或</td><td>两个操作数一个是true，结果就是true；左边取值是true，右边不会运算</td></tr></tbody></table><p>几点注意：</p><p>操作数只能是布尔型，操作结果也是布尔型<br>&amp; 和 &amp;&amp; 的区别： &amp;&amp; 左边是false时，不计算右边的表达式，左假即假； &amp; 无论左边真假都会计算右边的表达式<br>五、位运算符</p><table><thead><tr><th>运算符</th><th>含义</th><th>运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td><td>两个操作数都为1，结果为1</td></tr><tr><td>&#124;</td><td>按位或</td><td>两个操作数一个为1，结果为1</td></tr><tr><td>^</td><td>按位异或</td><td>两个操作数相同为0，不同为1</td></tr><tr><td>~</td><td>按位取反</td><td>操作数为1，结果为0；操作数为0，结果为1</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>右边空位补0</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>左边空位补最高位，即符号位</td></tr><tr><td>&gt;&gt;&gt;</td><td>无称号右移</td><td>左边空位补0</td></tr></tbody></table><p>示例: a和b是两个整数，下面是按位计算的形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = 0011 1100 ;    </span><br><span class="line">b = 0000 1101 ;</span><br><span class="line"></span><br><span class="line">a &amp; b = 0000 1100 ;</span><br><span class="line">a | b = 0011 1101 ;</span><br><span class="line">a ^ b = 0011 0001 ;</span><br><span class="line">~a = 1100 0011 ;</span><br><span class="line">a&lt;&lt;2  = 1111 0000 ;</span><br><span class="line">a&gt;&gt;2  = 1111 ;</span><br><span class="line">a&gt;&gt;&gt;2 = 0000 1111 ;</span><br></pre></td></tr></table></figure><p>六、三目运算符<br>也叫三元运算符，或是条件运算符，是Java语言中唯一需要三个操作数的运算符<br>符号:　表达式1 ? 表达式2 : 表达式3<br>如果表达式1为true，则返回表达式2的值，如果表达式1为false，则返回表达式3的值<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int m,n;</span><br><span class="line">m = 5&lt;10 ? 10 : 20;  //先判断5&lt;7，为真，则m = 10</span><br><span class="line">n = 5&gt;10 ? 10 : 20;  //先判断5&lt;7，为假，则n = 20</span><br></pre></td></tr></table></figure><p>七、instanceof运算符<br>instanceof运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型），结果返回一个布尔值<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;张三&quot;;</span><br><span class="line">boolean flag = name instanceof String;  //name是String类型的，返回true</span><br></pre></td></tr></table></figure><p>运算符号的优先级<br><!-- | 优先级|运算符|结合性|| ------ | ------ | ------ | --></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">含义</th><th>运算规则</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">( )　[ ] 　.</td><td>从左到右</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">! 　~　 ++　 –</td><td>从右到左</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">&#42;　 /　 &#37;</td><td>从左到右</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">+　 -</td><td>从左到右</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">&lt;&lt; 　&gt;&gt;　 &gt;&gt;&gt;</td><td>从左到右</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">&lt; 　&lt;=　 &gt; 　&gt;=　 instanceof</td><td>从左到右</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">== 　!=</td><td>从左到右</td></tr><tr><td style="text-align:center">8</td><td style="text-align:left">&amp;</td><td>从左到右</td></tr><tr><td style="text-align:center">9</td><td style="text-align:left">^</td><td>从左到右</td></tr><tr><td style="text-align:center">10</td><td style="text-align:left">&#124;</td><td>从左到右</td></tr><tr><td style="text-align:center">11</td><td style="text-align:left">&amp;&amp;</td><td>从左到右</td></tr><tr><td style="text-align:center">12</td><td style="text-align:left">&#124;&#124;</td><td>从左到右</td></tr><tr><td style="text-align:center">13</td><td style="text-align:left">? :</td><td>从左到右</td></tr><tr><td style="text-align:center">14</td><td style="text-align:left">= 　+= 　-= 　*=　 /=　 %=　 &amp;=　 &#124;=　 ^=　 ~= 　&lt;&lt;= 　&gt;&gt;=　 &gt;&gt;&gt;=</td><td>从右到左</td></tr><tr><td style="text-align:center">15</td><td style="text-align:left">，</td><td>从右到左</td></tr></tbody></table><p>当多个运算符出现在一个表达式中，谁的优先级别高，就先执行谁。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果完全不一样。<br>有一个口诀可以帮助记忆：</p><p>单算移关与，异或逻条赋<br>括号级别最高，逗号级别最低，单目 &gt; 算术 &gt; 位移 &gt; 关系 &gt; 逻辑 &gt; 三目 &gt; 赋值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基本数据类型和引用类型</title>
      <link href="/2019/12/09/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/12/09/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>八种基本数据类型<br><img src="/images/java基本数据类型和引用类型/基本数据类型.png" alt=""></p><p>除掉这四类八种基本类型，其它的都是对象，也就是引用类型，包括数组。</p><p>来看一段示例代码：</p><p>一个Person类，提供了一个构造方法，一些get/set方法：<br><img src="/images/java基本数据类型和引用类型/v2-cfd01239a6114d8f72352e7d5b44a41f_hd.png" alt=""></p><p>下面是测试的main方法：<br><img src="/images/java基本数据类型和引用类型/v2-a020f5f1b5b248f200391512cafb7513_hd.png" alt=""></p><p>先看第一句代码</p><p><img src="/images/java基本数据类型和引用类型/v2-44bced166052b8938755d5c8d4a9de3d_hd.png" alt=""><br>方法体里声明的基本数据类型在栈内存里，我们画一下<br><img src="/images/java基本数据类型和引用类型/v2-c6981f1aa0a68443af10c3de285026ea_hd.png" alt=""></p><p>继续执行以下代码</p><p><img src="/images/java基本数据类型和引用类型/v2-002755ee9e7ed63dc4b6d42e35bf9b8f_hd.png" alt=""></p><p>对于基本数据类型来说，赋值（=号）就相当于拷贝了一份值，把int1的值100，拷贝给int2，继续画图<br><img src="/images/java基本数据类型和引用类型/v2-fe67275640ecf78439111f7514919a7a_hd.png" alt=""></p><p>int1=500，直接修改int1的值为500，表现如下图<br><img src="/images/java基本数据类型和引用类型/v2-317de060c61f27d6c4093f586fb47c8a_hd.png" alt=""></p><p>分别打印int1，int2的值，相信没有人会答错，分别是500，100。再来看数组的初始化</p><p><img src="/images/java基本数据类型和引用类型/v2-4996988f6e9ecd487b5b000a28ceed0c_hd.png" alt=""></p><p>先初始化arr1，当执行到new这个关键字，会在堆内存分配内存空间，并把该内存空间的地址赋值给arr1。<br><img src="/images/java基本数据类型和引用类型/v2-2be66d9d5e691906a89fedd36a7b6c94_hd.png" alt=""></p><p>继续执行以下代码<br><img src="/images/java基本数据类型和引用类型/v2-76163c63cf6ba26ee9ecdf6aaf9e43d3_hd.png" alt=""></p><p>这儿arr2初始化时并没有new关键字，并不会在堆内存里新开辟一块空间，而是把arr1里存的堆内存地址直接赋值给了arr2，对于引用类型来说，赋值（=号）就相当于拷贝了一份内存地址，也就是说arr1，arr2现在指向了同一块堆内存，表现形势如下图<br><img src="/images/java基本数据类型和引用类型/v2-eec4ae0d9e4f0368632f83cdb84390ad_hd.png" alt=""></p><p>这时候执行如下代码<br><img src="/images/java基本数据类型和引用类型/v2-977c39560d6ff1b71196db80b5ff3023_hd.png" alt=""></p><p>虽然只是修改arr1数组下标位置为3的值<br><img src="/images/java基本数据类型和引用类型/v2-0b745eae4cec0d8544a3ed4ac38dbef6_hd.png" alt=""></p><p> 但由于<br> 数组arr1和数组arr2指向同一块堆内存，<br> 打印arr1[3]和arr2[3]的值，都是<br> 8。<br> 你答对了吗？再来看对象的初始化<br><img src="/images/java基本数据类型和引用类型/v2-2c5c3e2d89054e2a4996ed800739f357_hd.png" alt=""></p><p>当看到这个new，这货肯定在堆内存里开辟了一块内存空间，Person里有一个叫name的String对象，String这个对象有点特殊，虽然没有new这个关键字，但还是在堆内存中开辟了一块空间，在String是一个很普通的类一文中已经讲解过了，这里就不再细讲了，String底层是数组实现的，数组也是引用类型，age为基本数据类型，表现如下图<br><img src="/images/java基本数据类型和引用类型/v2-84aed37c59f46cd56a46bd6c54623cd3_hd.png" alt=""></p><p>上图中大框里的内容就是整个Person对象在堆内存中的体现，继续执行以下代码<br><img src="/images/java基本数据类型和引用类型/v2-24fb5472676485bc1d96a72f8f02ab9c_hd.png" alt=""></p><p>没有new关键字，per2不会在堆内存中新开辟空间，和数组一样，也是把per1的内存地址直接赋值给了per2<br><img src="/images/java基本数据类型和引用类型/v2-65a1a85bf445923e68edc51fcc950ac2_hd.png" alt=""></p><p>当我们修改per1的属性的时候<br><img src="/images/java基本数据类型和引用类型/v2-dcc8e0743cda50d7e19d05621039902b_hd.png" alt=""></p><p>如下图两个红框里的内容，给对象（数组也是对象）赋值其实就是相当于引用重新指向一块堆内存，基本数据类型是直接修改值，表现如下图<br><img src="/images/java基本数据类型和引用类型/v2-ff22a589b60f01fc3c54f771fb919a20_hd.png" alt=""></p><p>所以，不管打印per1还是per2的name、age，打印出来的结果都是<br>“李四”、35<br>，这个你也答对了吗？最后，我们来验证一下，结果是不是和文中说的一致。<br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""></p><p>结果完全一致，回过头来看看<br>Java里的“==”比较符，<br>结果就不难理解了，代码如下<br><img src="/images/java基本数据类型和引用类型/v2-01779bec27a57527d24750289eccf4dc_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java面试题及答案汇总-命名规则</title>
      <link href="/2019/12/09/java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
      <url>/2019/12/09/java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<pre><code>java程序是由类组成的；java应用程序必须有一个包含main方法的public类，main方法是程序的入口；java源文件的命名规则：如果有public类，那么源文件名就是public类名(一个文件中只能有一个public类)，而类名命名规则是：类的名字必须由大写字母开头而单词中的其他字母均为小写；如果类名称由多个单词组成，则每个单词的首字母均应为大写，如果类名称中包含单词缩写，则这个所写词的每个字母均应大写，命名类时应尽量选择名词。如果没有public类，就和遵循文件名命名规则；1.一个.java文件只能有1个public class(暗示可以没有)2.如果有public class,那么文件名必须与修饰符为public的类名相同(暗示,没有的话文件名可以随便起)其他：定义规范的目的是为了使项目的代码样式统一，使程序有良好的可读性。包的命名（全部小写，由域名定义）Java包的名字都是由小写单词组成。但是由于Java面向对象编程的特性，每一名Java程序员都 可以编写属于自己的Java包，为了保障每个Java包命名的唯一性，在最新的Java编程规范中，要求程序员在自己定义的包的名称之前加上唯一的前缀。 由于互联网上的域名称是不会重复的，所以程序员一般采用自己在互联网上的域名称作为自己程序包的唯一前缀。例如：net.frontfree.javagroup类的命名（单词首字母大写）根据约定，Java类名通常以大写字母开头，如果类名称由多个单词组成，则每个单词的首字母均应为大 写例如TestPage；如果类名称中包含单词缩写，则这个所写词的每个字母均应大写，如：XMLExample,还有一点命名技巧就是由于类是设计用来 代表对象的，所以在命名类时应尽量选择名词。例如： Graphics方法的命名（首字母小写，字母开头大写）方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头。例如：drawImage常量的命名（全部大写 ，常加下划线）常量的名字应该都使用大写字母，并且指出该常量完整含义。如果一个常量名称由多个单词组成，则应该用下划线来分割这些单词。例如：MAX_VALUE参数的命名参数的命名规范和方法的命名规范相同，而且为了避免阅读程序时造成迷惑，请在尽量保证参数名称为一个单词的情况下使参数的命名尽可能明确。Javadoc注释Java除了可以采用我们常见的注释方式之外，Java语言规范还定义了一种特殊的注释，也就是我们 所说的Javadoc注释，它是用来记录我们代码中的API的。Javadoc注释是一种多行注释，以/**开头，而以*/结束，注释可以包含一些 HTML标记符和专门的关键词。使用Javadoc 注释的好处是编写的注释可以被自动转为在线文档，省去了单独编写程序文档的麻烦。例如：/*** This is an example of* Javadoc* @author darchon* @version 0.1, 10/11/2002*/在每个程序的最开始部分，一般都用Javadoc注释对程序的总体描述以及版权信息，之后在主程序中 可以为每个类、接口、方法、字段添加 Javadoc注释，每个注释的开头部分先用一句话概括该类、接口、方法、字段所完成的功能，这句话应单独占据一行以突出其概括作用，在这句话后面可以跟 随更加详细的描述段落。在描述性段落之后还可以跟随一些以Javadoc注释标签开头的特殊段落，例如上面例子中的@auther和@version，这 些段落将在生成文档中以特定方式显示。变量和常量命名变量的命名主要的的命名规范有以下三种：Camel 标记法:首字母是小写的,接下来的单词都以大写字母开头Pascal 标记法:首字母是大写的,接下来的单词都以大写字母开头匈牙利标记法:在以Pascal标记法的变量前附加小写序列说明该变量的类型在Java我们一般使用匈牙利标记法，基本结构为scope_typeVariableName，它 使用1-3字符前缀来表示数据类型，3个字符的前缀必须小写，前缀后面是由表意性强的一个单词或多个单词组成的名字，而且每个单词的首写字母大写，其它字 母小写，这样保证了对变量名能够进行正确的断句。例如，定义一个整形变量，用来记录文档数量：intDocCount，其中int表明数据类型，后面为表 意的英文名，每个单词首字母大写。这样，在一个变量名就可以反映出变量类型和变量所存储的值的意义两方面内容，这使得代码语句可读性强、更加容易理解。 byte、int、char、long、float、 double、boolean和short。数据类型/前缀(附)byte bchar cshort shint ilong lchar cstring sfloat fdouble dhashtable h[] arrList lstVector vStringBuffer sbBoolean bByte btMap mapObject ob对于在多个函数内都要使用的全局变量，在前面再增加“g_”。例如一个全局的字符串变量：g_strUserInfo。在变量命名时要注意以下几点：· 选择有意义的名字，注意每个单词首字母要大写。· 在一段函数中不使用同一个变量表示前后意义不同的两个数值。· i、j、k等只作为小型循环的循环索引变量。· 避免用Flag来命名状态变量。· 用Is来命名逻辑变量，如：blnFileIsFound。通过这种给布尔变量肯定形式的命名方式，使得其它开发人员能够更为清楚的理解布尔变量所代表的意义。· 如果需要的话，在变量最后附加计算限定词，如：curSalesSum。· 命名不相包含，curSales和curSalesSum。· static final 变量(常量)的名字应该都大写，并且指出完整含义。· 如果需要对变量名进行缩写时，一定要注意整个代码中缩写规则的一致性。例如，如果在代码的某些区域中使用intCnt，而在另一些区域中又使用intCount，就会给代码增加不必要的复杂性。建议变量名中尽量不要出现缩写。· 通过在结尾处放置一个量词，就可创建更加统一的变量，它们更容易理解，也更容易搜索。例如，请使用 strCustomerFirst和strCustomerLast，而不要使用strFirstCustomer和strLastCustomer。常 用的量词后缀有：First（一组变量中的第一个）、Last（一组变量中的最后一个）、Next（一组变量中的下一个变量）、Prev（一组变量中的上 一个）、Cur（一组变量中的当前变量）。· 为每个变量选择最佳的数据类型，这样即能减少对内存的需求量，加快代码的执行速度，又会降低出错的可能性。用于变量的数据类型可能会影响该变量进行计算所产生的结果。在这种情况下，编译器不会产生运行期错误，它只是迫使该值符合数据类型的要求。这类问题极难查找。· 尽量缩小变量的作用域。如果变量的作用域大于它应有的范围，变量可继续存在，并且在不再需要该变量后的很长时间内仍然占用资源。它们的主要问题是，任何类 中的任何方法都能对它们进行修改，并且很难跟踪究竟是何处进行修改的。占用资源是作用域涉及的一个重要问题。对变量来说，尽量缩小作用域将会对应用程序的 可靠性产生巨大的影响。关于常量的命名方法，在JAVA代码中，无论什么时候，均提倡应用常量取代数字、固定字符串。也就是 说，程序中除0，1以外，尽量不应该出现其他数字。常量可以集中在程序开始部分定义或者更宽的作用域内，名字应该都使用大写字母，并且指出该常量完整含 义。如果一个常量名称由多个单词组成，则应该用下划线“_”来分割这些单词如：NUM_DAYS_IN_WEEK、MAX_VALUE。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>center os 部署 swoole</title>
      <link href="/2019/11/18/center%20os%20%E9%83%A8%E7%BD%B2%20swoole%20/"/>
      <url>/2019/11/18/center%20os%20%E9%83%A8%E7%BD%B2%20swoole%20/</url>
      
        <content type="html"><![CDATA[<p>今天通过pecl安装 swoole<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pecl install swoole</span><br></pre></td></tr></table></figure></p><p>步骤很简单，但是最后安装成功后发现phpinfo()中未显示swoole扩展，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -m | grep swoole</span><br></pre></td></tr></table></figure><p>发现报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP Warning: PHP Startup: Unable to load dynamic library &apos;/usr/lib64/php/modules/swoole.so&apos; - /usr/lib64/php/modules/swoole.so: undefined symbol: mysqlnd_find_charset_nr in Unknown on line 0</span><br></pre></td></tr></table></figure><br>        仔细看报错发现这条报错是由swoole.so报出来的，说明在加载swoole.so的时候报的找不到 mysqlnd_find_charset_nr ，这是一个以 mysqlnd 打头的一个关键字，而 mysqlnd 又是 PHP 的一个扩展，通过阅读 swoole/swoole.mysql.c 的源码我们发现有如下一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const MYSQLND_CHARSET* cset = mysqlnd_find_charset_nr(client-&gt;connector.character_set);</span><br><span class="line"> </span><br><span class="line">if (cset == NULL)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    swoole_php_fatal_error(E_ERROR, &quot;unknown mysql charset[%s].&quot;, client-&gt;connector.character_set);</span><br><span class="line"> </span><br><span class="line">    RETURN_FALSE;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码我们可以看出，原来 swoole 是需要依赖 msyqlnd 这个扩展的，我们发现 phpinfo() 里面 msyqlnd 扩展是存在的为什么还会报这个错呢。</p><p>　　最后发现 PHP默认加载的扩展都在 /usr/lib64/php/modules/ 这个目录里在，这里面的 .so 文件是默认加载的，关于这些扩展的配置不是在 /etc/php.ini 中，而是在 /etc/php.d/ 这个目录中，这个目录当中的所有的 .ini 文件是在 /etc/php.ini 加载完成后再加载的，而我们的 extension=swoole.so 的配置是写在 /etc/php.ini 的文件末尾，所以是先加载了 swoole.so 然后再加载 mysqlnd.so，这就导致了 swoole 找不到 mysqlnd_find_charset_nr 。</p><p>解决方法：<br>1、将/etc/php.d/ 目录中的mysqlnd.ini文件删除</p><p>2、在 /etc/php.ini 的 extension=swoole.so 上面一行添加 extension=mysqlnd.so</p><p>3、重新启动 php-fpm </p><p>这样可以解决问题了，同样可能还会遇到以下报错：</p><p>PHP Warning: PHP Startup: Unable to load dynamic library ‘/usr/lib64/php/modules/swoole.so’ - /usr/lib64/php/modules/swoole.so: undefined symbol: php_sockets_le_socket in Unknown on line 0</p><p>解决的方法也是类似的：</p><p>1、将/etc/php.d/ 目录中的sockets.ini文件删除</p><p>2、在 /etc/php.ini 的 extension=swoole.so 上面一行添加 extension=sockets.so</p><p>3、重新启动 php-fpm </p><p>问题解决，安装swoole过程中，如果有其它报错，也可以参考Github上关于swoole的issue，附上链接：</p><p>Swoole安装问题，及websocket示例问题总结</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java、tomcat安装与部署</title>
      <link href="/2019/11/18/java%E3%80%81tomcat%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/11/18/java%E3%80%81tomcat%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>java安装<br>一、下载jdk</p><p>jdk下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>下载jdk-8u152-linux-x64.rpm 或 jdk-8u152-linux-x64.tar.gz(根据自己的系统位数选择对应的包)</p><p>如图：</p><p>二、安装jdk</p><p>因为我安装的CentOS7.4系统自带jdk1.8，所以为了演示如何安装jdk，我需要先卸载系统自带的jdk</p><p>查看当前系统jdk的版本：java -version</p><p>列举匹配已安装的java的软件包：yum list installed | grep java</p><p>卸载安装的jdk：(yum命令参考：<a href="http://man.linuxde.net/yum" target="_blank" rel="noopener">http://man.linuxde.net/yum</a>)</p><p>yum -y remove java-1.7.0-openjdk*  </p><p>yum -y remove java-1.8.0-openjdk*</p><p>当结果出现了完毕！，就表示卸载成功。</p><p>安装jdk(介绍三种方法)</p><p>方法一：利用yum源来安装jdk（此方法不需要配置环境变量）</p><p>查看yum库中的java安装包 ：yum -y list java*</p><p>安装需要的jdk版本的所有java程序：yum -y install java-1.8.0-openjdk*</p><p>(安装完之后，默认的安装目录是在: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64)</p><p>当结果出现了完毕！即安装完成。</p><p>查看java版本：java -version</p><p>方法二：用rpm安装jdk(可以使用man rpm命令查看rpm的帮助文档)</p><p>使用Xftp将下载好的jdk-8u152-linux-x64.rpm上传到CentOs上去，我这里放到了/home/lisonglin下 </p><p>使用rpm命令安装： rpm -ivh jdk-8u152-linux-x64.rpm</p><p>(默认安装在/usr/java目录下，不用配置环境变量)</p><p>方法三：手动解压JDK的压缩包，然后设置环境变量</p><p>使用Xftp将下载好的jdk-8u152-linux-x64.tar.gz上传到CentOs上去，我这里放到了/home/lisonglin下</p><p>先将之前使用rpm方式安装的jdk卸载掉(如果没有安装过可跳过此步骤)</p><p>查询之前安装的jdk名称：rpm -qa | grep jdk</p><p>卸载jdk：rpm -e –nodeps jdk1.8    (此处也可以使用全名jdk1.8-1.8.0_152-fcs.x86_64)</p><p>卸载完成！</p><p>1、复制安装包到/usr/java目录中(目录可以自己选)：cp jdk-8u152-linux-x64.tar.gz  /usr/java</p><p>2、切换到/usr/java目录下：cd /usr/java</p><p>3、解压缩包：tar -zxvf jdk-8u152-linux-x64.tar.gz </p><p>解压成功（表式JDK已安装成功，可查看jdk的文件夹）</p><p>此时java -version命令还不能使用：</p><p>4、配置环境变量</p><p>使用vim /etc/profile 编辑profile文件 输入： vim /etc/profile</p><p>向文件里面追加以下内容：</p><p>#set java environment<br>JAVA_HOME=/usr/java/jdk1.8.0_152<br>JRE_HOME=$JAVA_HOME/jre<br>PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin<br>CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib<br>export JAVA_HOME JRE_HOME PATH CLASSPATH</p><p>注释：</p><p>JAVA_HOME指明JDK安装路径，就是刚才安装时所选择的路径，此路径下包括lib，bin，jre等文件夹（tomcat，Eclipse的运行都需要依靠此变量）。</p><p>CLASSPATH为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别，设：.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib。CLASSPATH变量值中的.表示当前目录</p><p>PATH使得系统可以在任何路径下识别java命令，设为：$JAVA_HOME/bin:$JRE_HOME/bin。</p><p>特别注意：环境变量值的结尾没有任何符号，不同值之间用:隔开（windows中用;）。</p><p>5、使配置文件生效：source /etc/profile</p><p>6、测试配置是否成功</p><p>tomcat</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>php7打开页面为空白</title>
      <link href="/2019/06/27/php7%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%E4%B8%BA%E7%A9%BA%E7%99%BD/"/>
      <url>/2019/06/27/php7%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%E4%B8%BA%E7%A9%BA%E7%99%BD/</url>
      
        <content type="html"><![CDATA[<p>由于nginx与php-fpm之间的一个小bug，会导致这样的现象： 网站中的静态页面 <em>.html 都能正常访问，而 </em>.php 文件虽然会返回200状态码， 但实际输出给浏览器的页面内容却是空白。 简而言之，原因是nginx无法正确的将 *.php 文件的地址传递给php-fpm去解析， 相当于php-fpm接受到了请求，但这请求却指向一个不存在的文件，于是返回空结果。 为了解决这个问题，需要改动nginx默认的fastcgiparams配置文件： vi /etc/nginx/fastcgi_params 在文件的最后增加两行： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">fastcgi_param PATH_INFO                $fastcgi_script_name;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> php </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ssh登录</title>
      <link href="/2019/06/17/ssh/"/>
      <url>/2019/06/17/ssh/</url>
      
        <content type="html"><![CDATA[<p>秘钥登录</p><ol><li>打开 SSH 客户端（ Mac 自带终端）。</li><li>输入 ssh <a href="mailto:root@x.x.x.x" target="_blank" rel="noopener">root@x.x.x.x</a> 或者输入 ssh -q -l root -p 22 x.x.x.x</li><li>输入密码。</li></ol><p>证书登录</p><ol><li>打开 SSH 客户端（ Mac 自带终端）。</li><li>查找您云服务器关联的 SSH 密钥文件本地存放地址。</li><li><p>密钥必须不公开可见，SSH 才能工作。<br> chmod 400 documents/summary/tencentcloud/tencent_cloud_ssh.dms</p></li><li><p>输入命令：ssh [-i 密钥文件路径] <a href="mailto:root@x.x.x.x" target="_blank" rel="noopener">root@x.x.x.x</a>。<br> ssh -i “documents/summary/tencentcloud/tencent_cloud_ssh.dms” <a href="mailto:root@x.x.x.x" target="_blank" rel="noopener">root@x.x.x.x</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>php混淆文件</title>
      <link href="/2019/06/13/php%E6%B7%B7%E6%B7%86/"/>
      <url>/2019/06/13/php%E6%B7%B7%E6%B7%86/</url>
      
        <content type="html"><![CDATA[<p>使用方式：</p><p>修改 filename 为文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line"> </span><br><span class="line"> function RandAbc($length = &quot;&quot;) &#123; // 返回随机字符串  </span><br><span class="line">     $str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;  </span><br><span class="line">     return str_shuffle($str);  </span><br><span class="line"> &#125;   </span><br><span class="line"> </span><br><span class="line"> $filename = &apos;Api.php&apos;; //要加密的文件  </span><br><span class="line"> $T_k1 = RandAbc(); //随机密匙1  </span><br><span class="line"> $T_k2 = RandAbc(); //随机密匙2  </span><br><span class="line"> $vstr = file_get_contents($filename);  </span><br><span class="line"> $v1 = base64_encode($vstr);  </span><br><span class="line"> $c = strtr($v1, $T_k1, $T_k2); //根据密匙替换对应字符。  </span><br><span class="line"> $c = $T_k1.$T_k2.$c;  </span><br><span class="line"> $q1 = &quot;O00O0O&quot;;  </span><br><span class="line"> $q2 = &quot;O0O000&quot;;  </span><br><span class="line"> $q3 = &quot;O0OO00&quot;;  </span><br><span class="line"> $q4 = &quot;OO0O00&quot;;  </span><br><span class="line"> $q5 = &quot;OO0000&quot;;  </span><br><span class="line"> $q6 = &quot;O00OO0&quot;;  </span><br><span class="line"> $s = &apos;$&apos;.$q6.&apos;=urldecode(&quot;%6E1%7A%62%2F%6D%615%5C%76%740%6928%2D%70%78%75%71%79%2A6%6C%72%6B%64%679%5F%65%68%63%73%77%6F4%2B%6637%6A&quot;);$&apos;.$q1.&apos;=$&apos;.$q6.&apos;&#123;3&#125;.$&apos;.$q6.&apos;&#123;6&#125;.$&apos;.$q6.&apos;&#123;33&#125;.$&apos;.$q6.&apos;&#123;30&#125;;$&apos;.$q3.&apos;=$&apos;.$q6.&apos;&#123;33&#125;.$&apos;.$q6.&apos;&#123;10&#125;.$&apos;.$q6.&apos;&#123;24&#125;.$&apos;.$q6.&apos;&#123;10&#125;.$&apos;.$q6.&apos;&#123;24&#125;;$&apos;.$q4.&apos;=$&apos;.$q3.&apos;&#123;0&#125;.$&apos;.$q6.&apos;&#123;18&#125;.$&apos;.$q6.&apos;&#123;3&#125;.$&apos;.$q3.&apos;&#123;0&#125;.$&apos;.$q3.&apos;&#123;1&#125;.$&apos;.$q6.&apos;&#123;24&#125;;$&apos;.$q5.&apos;=$&apos;.$q6.&apos;&#123;7&#125;.$&apos;.$q6.&apos;&#123;13&#125;;$&apos;.$q1.&apos;.=$&apos;.$q6.&apos;&#123;22&#125;.$&apos;.$q6.&apos;&#123;36&#125;.$&apos;.$q6.&apos;&#123;29&#125;.$&apos;.$q6.&apos;&#123;26&#125;.$&apos;.$q6.&apos;&#123;30&#125;.$&apos;.$q6.&apos;&#123;32&#125;.$&apos;.$q6.&apos;&#123;35&#125;.$&apos;.$q6.&apos;&#123;26&#125;.$&apos;.$q6.&apos;&#123;30&#125;;eval($&apos;.$q1.&apos;(&quot;&apos;.base64_encode(&apos;$&apos;.$q2.&apos;=&quot;&apos;.$c.&apos;&quot;;eval(\&apos;?&gt;\&apos;.$&apos;.$q1.&apos;($&apos;.$q3.&apos;($&apos;.$q4.&apos;($&apos;.$q2.&apos;,$&apos;.$q5.&apos;*2),$&apos;.$q4.&apos;($&apos;.$q2.&apos;,$&apos;.$q5.&apos;,$&apos;.$q5.&apos;),$&apos;.$q4.&apos;($&apos;.$q2.&apos;,0,$&apos;.$q5.&apos;))));&apos;).&apos;&quot;));&apos;;  </span><br><span class="line"> </span><br><span class="line"> $s = &apos;&lt;?php &apos;.&quot;\n&quot;.$s.&quot;\n&quot;.&apos; ?&gt;&apos;;  </span><br><span class="line"> //echo $s;  </span><br><span class="line"> // 生成 加密后的PHP文件  </span><br><span class="line"> $fpp1 = fopen(&apos;temp_&apos;.$filename, &apos;w&apos;);  </span><br><span class="line"> fwrite($fpp1, $s) or die(&apos;写文件错误&apos;);  </span><br><span class="line"> </span><br><span class="line"> ?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android选择打包类型(release、debug)</title>
      <link href="/2019/06/04/android%E9%80%89%E6%8B%A9%E6%89%93%E5%8C%85%E7%B1%BB%E5%9E%8B(release%E3%80%81debug)/"/>
      <url>/2019/06/04/android%E9%80%89%E6%8B%A9%E6%89%93%E5%8C%85%E7%B1%BB%E5%9E%8B(release%E3%80%81debug)/</url>
      
        <content type="html"><![CDATA[<ol><li>在Android Studio 顶部栏中有Build 下拉菜单中有 select Build Variants… </li><li>在Build Variants 中model 选择需要输出的arr 包类型，debug 或者 release 类型</li><li>在Android Studio 顶部栏中有Build 下拉菜单中有 Rebuild Project</li><li>在Model 的build/outputs/arr/ 输出arr 文件</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>linux配置开机脚本、以其他用户身份运行</title>
      <link href="/2019/04/26/linux%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/04/26/linux%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>1.开机脚本</p><p>linux开机的时候会自动执行 /etc/rc.local 里面的命令<br>将命令写在 exit 0 之前便可执行</p><p>2.以其他用户身份运行</p><p>以其他身份用户运行并修改可以避免操作修改了文件所有者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - ubuntu -c &apos;cd COMMAND&apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>php7安装redis扩展</title>
      <link href="/2019/04/12/php7%E5%AE%89%E8%A3%85redis%E6%89%A9%E5%B1%95/"/>
      <url>/2019/04/12/php7%E5%AE%89%E8%A3%85redis%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br><span class="line">apt-get install php7.0-dev        # 为了有phpize命令</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/phpredis/phpredis.git # 下载redi包，需要翻墙才能下载</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd phpredis</span><br><span class="line">git checkout php7</span><br><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cd ..</span><br><span class="line">rm -rf phpredis</span><br></pre></td></tr></table></figure><p>最后将 extension=redis.so 写入php.ini文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用gitlab CI/CD 完成自动部署</title>
      <link href="/2019/02/15/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/02/15/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>添加Gitlab的官方源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># For Debian/Ubuntu</span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bash</span><br><span class="line"></span><br><span class="line"># For CentOS</span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure></p><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># For Debian/Ubuntu</span><br><span class="line">sudo apt-get install gitlab-ci-multi-runner</span><br><span class="line"></span><br><span class="line"># For CentOS</span><br><span class="line">sudo yum install gitlab-ci-multi-runner</span><br></pre></td></tr></table></figure></p><p>注册Runner<br>Runner需要注册到Gitlab才可以被项目所使用，一个gitlab-ci-multi-runner服务可以注册多个Runner。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gitlab-ci-multi-runner register</span><br><span class="line"></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line">https://mygitlab.com/ci</span><br><span class="line">Please enter the gitlab-ci token for this runner</span><br><span class="line">xxx-xxx-xxx</span><br><span class="line">Please enter the gitlab-ci description for this runner</span><br><span class="line">my-runner</span><br><span class="line">INFO[0034] fcf5c619 Registering runner... succeeded</span><br><span class="line">Please enter the executor: shell, docker, docker-ssh, ssh?</span><br><span class="line">docker</span><br><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">node:4.5.0</span><br><span class="line">INFO[0037] Runner registered successfully. Feel free to start it, but if it&apos;s</span><br><span class="line">running already the config should be automatically reloaded!</span><br></pre></td></tr></table></figure></p><p>更新Runner<br>如果需要更新Runner，只需要执行以下脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># For Debian/Ubuntu</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gitlab-ci-multi-runner</span><br><span class="line"></span><br><span class="line"># For CentOS</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install gitlab-ci-multi-runner</span><br></pre></td></tr></table></figure><br>  Runner高级配置<br>通过gitlab-ci-multi-runner register注册的Runner配置会存储在/etc/gitlab-runner/config.toml中，如果需要修改可直接编辑该文件。详见这里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">concurrent = 4</span><br><span class="line">check_interval = 0</span><br><span class="line"></span><br><span class="line">[[runners]]</span><br><span class="line">  name = &quot;test&quot;</span><br><span class="line">  url = &quot;http://your-domain.com/ci&quot;</span><br><span class="line">  token = &quot;your-token&quot;</span><br><span class="line">  executor = &quot;docker&quot;</span><br><span class="line">  [runners.docker]</span><br><span class="line">    tls_verify = false</span><br><span class="line">    image = &quot;node:4.5.0&quot;</span><br><span class="line">    privileged = false</span><br><span class="line">    disable_cache = false</span><br><span class="line">    volumes = [&quot;/cache&quot;]</span><br><span class="line">  [runners.cache]</span><br><span class="line">  [runners.kubernetes]</span><br><span class="line">    host = &quot;&quot;</span><br><span class="line">    cert_file = &quot;&quot;</span><br><span class="line">    key_file = &quot;&quot;</span><br><span class="line">    ca_file = &quot;&quot;</span><br><span class="line">    image = &quot;&quot;</span><br><span class="line">    namespace = &quot;&quot;</span><br><span class="line">    privileged = false</span><br><span class="line">    cpus = &quot;&quot;</span><br><span class="line">    memory = &quot;&quot;</span><br><span class="line">    service_cpus = &quot;&quot;</span><br><span class="line">    service_memory = &quot;&quot;</span><br></pre></td></tr></table></figure><br>到这里我们的Runner就安装配置好了，接下来是对项目根目录中.gitlab-ci.yml进行配置。</p><p>配置构建任务<br>在项目根目录添加.gitlab-ci.yml文件<br>关于该文件的各项配置请见</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 这里使用了我自己的docker image，配置了自己需要的环境</span><br><span class="line">image: wuyanxin/node</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">MYSQL_DATABASE: wan_ark-unit</span><br><span class="line">MYSQL_ALLOW_EMPTY_PASSWORD: &quot;yes&quot;</span><br><span class="line"></span><br><span class="line"># 关于service请见: http://docs.gitlab.com/ce/ci/docker/using_docker_images.html#what-is-service</span><br><span class="line">services:</span><br><span class="line">- mysql:5.6</span><br><span class="line">- redis:3.2.4</span><br><span class="line"></span><br><span class="line">stages:</span><br><span class="line">- test</span><br><span class="line">- eslint</span><br><span class="line">- deploy</span><br><span class="line"></span><br><span class="line">before_script:</span><br><span class="line">- echo &apos;REDIS_HOST=redis&apos; &gt;&gt; .env</span><br><span class="line">- echo &apos;DB_HOST=mysql&apos; &gt;&gt; .env</span><br><span class="line">- yarn install</span><br><span class="line"></span><br><span class="line">test_service:</span><br><span class="line">stage: test</span><br><span class="line">script:</span><br><span class="line">- npm run build</span><br><span class="line">- npm test</span><br><span class="line"></span><br><span class="line">eslint_src: </span><br><span class="line">stage: eslint</span><br><span class="line">script:</span><br><span class="line">- npm run lint</span><br><span class="line">allow_failure: true</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">stage: deploy</span><br><span class="line">script:</span><br><span class="line">- echo &apos;deployd!&apos;</span><br><span class="line">only: </span><br><span class="line">- master</span><br></pre></td></tr></table></figure><br>这里使用了nodejs项目作为例子，其他语言类似语法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue引用element-ui与webpack</title>
      <link href="/2019/02/12/vue%E5%BC%95%E7%94%A8element-ui/"/>
      <url>/2019/02/12/vue%E5%BC%95%E7%94%A8element-ui/</url>
      
        <content type="html"><![CDATA[<p>从新建vue项目到引入组件Element<br>一、新建项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.查看 node和npm是不是已经安装好命令：node -v  npm -v (没有安装的先安装环境);</span><br><span class="line">2.npm install -g cnpm --registry=https://registry.npm.taobao.org  (安装国内的淘宝镜像文件，后面的安装npm可以全部改为cnpm)</span><br><span class="line">3.安装 vue-cli   </span><br><span class="line">1、cnpm install -g vue</span><br><span class="line">2、cnpm install -g vue-cli </span><br><span class="line">4. 安装 webpack   cnpm install -g webpack </span><br><span class="line">5.cd  你的运行目录</span><br><span class="line">6.新建vue项目      vue init webpack vuedemo</span><br><span class="line">7.进入项目目录     cd vuedemo</span><br><span class="line">8.安装依赖        cnpm install</span><br><span class="line">9.运行项目        cnpm run dev</span><br><span class="line">10.发布项目       cnpm run build</span><br><span class="line">注：mac电脑需要在安装淘宝镜像前执行： sudo chown -R $USER /usr/local</span><br></pre></td></tr></table></figure><br>二、使用element-ui前需安装修改的配置：</p><ol><li>安装 loader 模块：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnpm install style-loader -D</span><br><span class="line">cnpm install css-loader -D</span><br><span class="line">cnpm install file-loader -D</span><br></pre></td></tr></table></figure></li><li>安装 Element-UI 模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install element-ui --save </span><br></pre></td></tr></table></figure>三、引入Element，前面已经全局安装了element-ui，只需要在Vue项目中引入即可<br>打开项目：src/main.js,添加下面三条<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from &apos;element-ui&apos;</span><br><span class="line">import &apos;element-ui/lib/theme-chalk/index.css&apos;</span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure></li></ol><p>四、然后在.vue文件里就直接可以用了</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cytoscape在vue中安装实例</title>
      <link href="/2019/02/11/Cytoscape%E5%9C%A8vue%E4%B8%AD%E5%AE%89%E8%A3%85%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/02/11/Cytoscape%E5%9C%A8vue%E4%B8%AD%E5%AE%89%E8%A3%85%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>首先创建vue项目，并在项目下安装Cytoscape包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue create test #创建vue项目</span><br><span class="line">cd test</span><br><span class="line">npm i cytoscape --save #加载cytoscape模块</span><br></pre></td></tr></table></figure><br>创建index.vue文件并且写入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;cy&quot; style=&quot;width: 100%;height: 100%;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var cytoscape = require(&quot;cytoscape&quot;);</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Cytoscape&quot;,</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  created: function() &#123;&#125;,</span><br><span class="line">  data: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      input: &quot;&quot;,</span><br><span class="line">      output: &quot;&quot;,</span><br><span class="line">      msg: &quot;vue to cytoscape&quot;,</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add_node: function() &#123;</span><br><span class="line">      console.info(this.cy);</span><br><span class="line">      this.cy.add([</span><br><span class="line">        &#123;</span><br><span class="line">          group: &quot;nodes&quot;,</span><br><span class="line">          data: &#123; id: &quot;node&quot; + this.count &#125;,</span><br><span class="line">          position: &#123; x: 300, y: 200 &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          group: &quot;edges&quot;,</span><br><span class="line">          data: &#123;</span><br><span class="line">            id: &quot;edge&quot; + this.count,</span><br><span class="line">            source: &quot;node&quot; + this.count,</span><br><span class="line">            target: &quot;cat&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]);</span><br><span class="line">    &#125;,</span><br><span class="line">    view_init: function() &#123;</span><br><span class="line">      this.cy = cytoscape(&#123;</span><br><span class="line">        container: document.getElementById(&quot;cy&quot;),</span><br><span class="line">        boxSelectionEnabled: false,</span><br><span class="line">        autounselectify: true,</span><br><span class="line">        style: cytoscape</span><br><span class="line">          .stylesheet()</span><br><span class="line">          .selector(&quot;node&quot;)</span><br><span class="line">          .css(&#123;</span><br><span class="line">            height: 80,</span><br><span class="line">            width: 80,</span><br><span class="line">            &quot;background-fit&quot;: &quot;cover&quot;,</span><br><span class="line">            &quot;border-color&quot;: &quot;#000&quot;,</span><br><span class="line">            &quot;border-width&quot;: 3,</span><br><span class="line">            &quot;border-opacity&quot;: 0.5,</span><br><span class="line">            content: &quot;data(id)&quot;,</span><br><span class="line">            &quot;text-valign&quot;: &quot;center&quot;</span><br><span class="line">          &#125;)</span><br><span class="line">          .selector(&quot;.aa&quot;)</span><br><span class="line">          .css(&#123;</span><br><span class="line">            height: 80,</span><br><span class="line">            width: 80,</span><br><span class="line">            &quot;background-fit&quot;: &quot;cover&quot;,</span><br><span class="line">            &quot;border-color&quot;: &quot;red&quot;,</span><br><span class="line">            &quot;border-width&quot;: 3,</span><br><span class="line">            &quot;border-opacity&quot;: 0.5,</span><br><span class="line">            &quot;background-color&quot;: &quot;red&quot;,</span><br><span class="line">            content: &quot;data(id)&quot;,</span><br><span class="line">            &quot;text-valign&quot;: &quot;center&quot;,</span><br><span class="line">            &quot;line-color&quot;: &quot;red&quot;,</span><br><span class="line">          &#125;)</span><br><span class="line">          </span><br><span class="line">          .selector(&quot;edge&quot;)</span><br><span class="line">          .css(&#123;</span><br><span class="line">            width: 6,</span><br><span class="line">            &quot;target-arrow-shape&quot;: &quot;triangle&quot;,</span><br><span class="line">            &quot;line-color&quot;: &quot;#ffaaaa&quot;,</span><br><span class="line">            &quot;target-arrow-color&quot;: &quot;#ffaaaa&quot;,</span><br><span class="line">            &quot;curve-style&quot;: &quot;bezier&quot;</span><br><span class="line">          &#125;)</span><br><span class="line">          .selector(&quot;.bb&quot;)</span><br><span class="line">          .css(&#123;</span><br><span class="line">            &quot;line-color&quot;: &quot;#000&quot;,</span><br><span class="line">          &#125;),</span><br><span class="line"></span><br><span class="line">        elements: &#123;</span><br><span class="line">          nodes: [</span><br><span class="line">            &#123; data: &#123; id: &quot;cat&quot; &#125;, classes: [&quot;aa&quot;] &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;bird&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;ladybug&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;aphid&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;rose&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;grasshopper&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;plant&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;wheat&quot; &#125; &#125;</span><br><span class="line">          ],</span><br><span class="line">          edges: [</span><br><span class="line">            &#123; data: &#123; source: &quot;cat&quot;, target: &quot;bird&quot; &#125;, classes: [&quot;bb&quot;] &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;bird&quot;, target: &quot;ladybug&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;bird&quot;, target: &quot;grasshopper&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;grasshopper&quot;, target: &quot;plant&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;grasshopper&quot;, target: &quot;wheat&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;ladybug&quot;, target: &quot;aphid&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;aphid&quot;, target: &quot;rose&quot; &#125; &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        layout: &#123;</span><br><span class="line">          name: &quot;breadthfirst&quot;,</span><br><span class="line">          directed: true,</span><br><span class="line">          padding: 10</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  mounted: function() &#123;</span><br><span class="line">    this.view_init();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">#cy &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 80%;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50px;</span><br><span class="line">  left: 0px;</span><br><span class="line">  text-align: left;</span><br><span class="line">&#125;</span><br><span class="line">.aa &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  /* font: 14px helvetica neue, helvetica, arial, sans-serif; */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><br>一个简单的示例就创建成功了，具体内容可以根据自己的需求来修改。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>运用wrk进行压力测试</title>
      <link href="/2019/01/09/%E8%BF%90%E7%94%A8wrk%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/01/09/%E8%BF%90%E7%94%A8wrk%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>用过了很多压测工具，却一直没找到中意的那款。最近试了wrk感觉不错，写下这份使用指南给自己备忘用，如果能帮到你，那也很好。<br><a id="more"></a><br>安装<br>wrk支持大多数类UNIX系统，不支持windows。需要操作系统支持LuaJIT和OpenSSL，不过不用担心，大多数类Unix系统都支持。安装wrk非常简单，只要从github上下载wrk源码，在项目路径下执行make命令即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg/wrk</span><br><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure><br>make之后，会在项目路径下生成可执行文件wrk，随后就可以用其进行HTTP压测了。可以把这个可执行文件拷贝到某个已在path中的路径，比如/usr/local/bin，这样就可以在任何路径直接使用wrk了。</p><p>默认情况下wrk会使用自带的LuaJIT和OpenSSL，如果你想使用系统已安装的版本，可以使用WITH_LUAJIT和WITH_OPENSSL这两个选项来指定它们的路径。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make WITH_LUAJIT=/usr WITH_OPENSSL=/usr</span><br></pre></td></tr></table></figure><br>基本使用<br>命令行敲下wrk，可以看到使用帮助<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Usage: wrk &lt;options&gt; &lt;url&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  Connections to keep open   </span><br><span class="line">    -d, --duration    &lt;T&gt;  Duration of test           </span><br><span class="line">    -t, --threads     &lt;N&gt;  Number of threads to use   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  Load Lua script file       </span><br><span class="line">    -H, --header      &lt;H&gt;  Add header to request      </span><br><span class="line">        --latency          Print latency statistics   </span><br><span class="line">        --timeout     &lt;T&gt;  Socket/request timeout     </span><br><span class="line">    -v, --version          Print version details      </span><br><span class="line">                                                      </span><br><span class="line">  Numeric arguments may include a SI unit (1k, 1M, 1G)</span><br><span class="line">  Time arguments may include a time unit (2s, 2m, 2h)</span><br></pre></td></tr></table></figure><br>简单翻成中文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  跟服务器建立并保持的TCP连接数量  </span><br><span class="line">    -d, --duration    &lt;T&gt;  压测时间           </span><br><span class="line">    -t, --threads     &lt;N&gt;  使用多少个线程进行压测   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  指定Lua脚本路径       </span><br><span class="line">    -H, --header      &lt;H&gt;  为每一个HTTP请求添加HTTP头      </span><br><span class="line">        --latency          在压测结束后，打印延迟统计信息   </span><br><span class="line">        --timeout     &lt;T&gt;  超时时间     </span><br><span class="line">    -v, --version          打印正在使用的wrk的详细版本信息</span><br><span class="line">                                                      </span><br><span class="line">  &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)</span><br><span class="line">  &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)</span><br></pre></td></tr></table></figure><br>看下版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrk -v</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">wrk 4.0.2 [epoll] Copyright (C) 2012 Will Glozer</span><br></pre></td></tr></table></figure><br>看到是4.0.2版本的wrk，使用了epoll。这意味着我们可以用少量的线程来跟被测服务创建大量连接，进行压测。</p><p>做一次简单压测，分析下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wrk -t8 -c200 -d30s --latency  &quot;http://www.bing.com&quot;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Running 30s test @ http://www.bing.com</span><br><span class="line">  8 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency    46.67ms  215.38ms   1.67s    95.59%</span><br><span class="line">    Req/Sec     7.91k     1.15k   10.26k    70.77%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    2.93ms</span><br><span class="line">     75%    3.78ms</span><br><span class="line">     90%    4.73ms</span><br><span class="line">     99%    1.35s </span><br><span class="line">  1790465 requests in 30.01s, 684.08MB read</span><br><span class="line">Requests/sec:  59658.29</span><br><span class="line">Transfer/sec:     22.79MB</span><br></pre></td></tr></table></figure><br>以上使用8个线程200个连接，对bing首页进行了30秒的压测，并要求在压测结果中输出响应延迟信息。以下对压测结果进行简单注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Running 30s test @ http://www.bing.com （压测时间30s）</span><br><span class="line">  8 threads and 200 connections （共8个测试线程，200个连接）</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">              （平均值） （标准差）（最大值）（正负一个标准差所占比例）</span><br><span class="line">    Latency    46.67ms  215.38ms   1.67s    95.59%</span><br><span class="line">    （延迟）</span><br><span class="line">    Req/Sec     7.91k     1.15k   10.26k    70.77%</span><br><span class="line">    （处理中的请求数）</span><br><span class="line">  Latency Distribution （延迟分布）</span><br><span class="line">     50%    2.93ms</span><br><span class="line">     75%    3.78ms</span><br><span class="line">     90%    4.73ms</span><br><span class="line">     99%    1.35s （99分位的延迟）</span><br><span class="line">  1790465 requests in 30.01s, 684.08MB read （30.01秒内共处理完成了1790465个请求，读取了684.08MB数据）</span><br><span class="line">Requests/sec:  59658.29 （平均每秒处理完成59658.29个请求）</span><br><span class="line">Transfer/sec:     22.79MB （平均每秒读取数据22.79MB）</span><br></pre></td></tr></table></figure><p>可以看到，wrk使用方便，结果清晰。并且因为非阻塞IO的使用，可以在普通的测试机上创建出大量的连接，从而达到较好的压测效果。</p><p>使用Lua脚本个性化wrk压测<br>以上两节安装并简单使用了wrk，但这种简单的压测可能不能满足我们的需求。比如我们可能需要使用POST METHOD跟服务器交互；可能需要为每一次请求使用不同的参数，以更好的模拟服务的实际使用场景等。wrk支持用户使用–script指定Lua脚本，来定制压测过程，满足个性化需求。</p><p>介绍wrk对Lua脚本的支持<br>wrk支持在三个阶段对压测进行个性化，分别是启动阶段、运行阶段和结束阶段。每个测试线程，都拥有独立的Lua运行环境。</p><p>启动阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function setup(thread)</span><br></pre></td></tr></table></figure><br>在脚本文件中实现setup方法，wrk就会在测试线程已经初始化但还没有启动的时候调用该方法。wrk会为每一个测试线程调用一次setup方法，并传入代表测试线程的对象thread作为参数。setup方法中可操作该thread对象，获取信息、存储信息、甚至关闭该线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread.addr             - get or set the thread&apos;s server address</span><br><span class="line">thread:get(name)        - get the value of a global in the thread&apos;s env</span><br><span class="line">thread:set(name, value) - set the value of a global in the thread&apos;s env</span><br><span class="line">thread:stop()           - stop the thread</span><br><span class="line">运行阶段</span><br><span class="line">function init(args)</span><br><span class="line">function delay()</span><br><span class="line">function request()</span><br><span class="line">function response(status, headers, body)</span><br></pre></td></tr></table></figure><p>init由测试线程调用，只会在进入运行阶段时，调用一次。支持从启动wrk的命令中，获取命令行参数； delay在每次发送request之前调用，如果需要delay，那么delay相应时间； request用来生成请求；每一次请求都会调用该方法，所以注意不要在该方法中做耗时的操作； reponse在每次收到一个响应时调用；为提升性能，如果没有定义该方法，那么wrk不会解析headers和body；</p><p>结束阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function done(summary, latency, requests)</span><br></pre></td></tr></table></figure><br>该方法在整个测试过程中只会调用一次，可从参数给定的对象中，获取压测结果，生成定制化的测试报告。</p><p>自定义脚本中可访问的变量和方法<br>变量：wrk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wrk = &#123;</span><br><span class="line">   scheme  = &quot;http&quot;,</span><br><span class="line">   host    = &quot;localhost&quot;,</span><br><span class="line">   port    = nil,</span><br><span class="line">   method  = &quot;GET&quot;,</span><br><span class="line">   path    = &quot;/&quot;,</span><br><span class="line">   headers = &#123;&#125;,</span><br><span class="line">   body    = nil,</span><br><span class="line">   thread  = &lt;userdata&gt;,</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>一个table类型的变量wrk，是全局变量，修改该table，会影响所有请求。</p><p>方法：wrk.fomat wrk.lookup wrk.connect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function wrk.format(method, path, headers, body)</span><br><span class="line"></span><br><span class="line">  wrk.format returns a HTTP request string containing the passed parameters</span><br><span class="line">  merged with values from the wrk table.</span><br><span class="line">  根据参数和全局变量wrk，生成一个HTTP rquest string。</span><br><span class="line"></span><br><span class="line">function wrk.lookup(host, service)</span><br><span class="line"></span><br><span class="line">  wrk.lookup returns a table containing all known addresses for the host</span><br><span class="line">  and service pair. This corresponds to the POSIX getaddrinfo() function.</span><br><span class="line">  给定host和service（port/well known service name），返回所有可用的服务器地址信息。</span><br><span class="line"></span><br><span class="line">function wrk.connect(addr)</span><br><span class="line"></span><br><span class="line">  wrk.connect returns true if the address can be connected to, otherwise</span><br><span class="line">  it returns false. The address must be one returned from wrk.lookup().</span><br><span class="line">  测试与给定的服务器地址信息是否可以成功创建连接</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>示例<br>使用POST METHOD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wrk.method = &quot;POST&quot;</span><br><span class="line">wrk.body   = &quot;foo=bar&amp;baz=quux&quot;</span><br><span class="line">wrk.headers[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;</span><br></pre></td></tr></table></figure><p>通过修改全局变量wrk，使得所有请求都使用POST方法，并指定了body和Content-Type头。</p><p>为每次request更换一个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request = function()</span><br><span class="line">   uid = math.random(1, 10000000)</span><br><span class="line">   path = &quot;/test?uid=&quot; .. uid</span><br><span class="line">   return wrk.format(nil, path)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>通过在request方法中随机生成1~10000000之间的uid，使得请求中的uid参数随机。</p><p>每次请求之前延迟10ms<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function delay()</span><br><span class="line">   return 10</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>每个线程要先进行认证，认证之后获取token以进行压测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">token = nil</span><br><span class="line">path  = &quot;/authenticate&quot;</span><br><span class="line"></span><br><span class="line">request = function()</span><br><span class="line">   return wrk.format(&quot;GET&quot;, path)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">response = function(status, headers, body)</span><br><span class="line">   if not token and status == 200 then</span><br><span class="line">      token = headers[&quot;X-Token&quot;]</span><br><span class="line">      path  = &quot;/resource&quot;</span><br><span class="line">      wrk.headers[&quot;X-Token&quot;] = token</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>在没有token的情况下，先访问/authenticate认证。认证成功后，读取token并替换path为/resource。</p><p>压测支持HTTP pipeline的服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">init = function(args)</span><br><span class="line">   local r = &#123;&#125;</span><br><span class="line">   r[1] = wrk.format(nil, &quot;/?foo&quot;)</span><br><span class="line">   r[2] = wrk.format(nil, &quot;/?bar&quot;)</span><br><span class="line">   r[3] = wrk.format(nil, &quot;/?baz&quot;)</span><br><span class="line"></span><br><span class="line">   req = table.concat(r)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">request = function()</span><br><span class="line">   return req</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>通过在init方法中将三个HTTP request请求拼接在一起，实现每次发送三个请求，以使用HTTP pipeline。</p><p>最后<br>源码非常简洁，简单读了读，很佩服wrk的作者。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>创建多个ssh-key</title>
      <link href="/2018/12/19/%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAssh-key/"/>
      <url>/2018/12/19/%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAssh-key/</url>
      
        <content type="html"><![CDATA[<p>生产环境下经常需要为同一台机器配置多个ssh-key并且在访问指定服务器时使用指定的key<br><a id="more"></a><br>首先简单了解一下ssh：</p><p>Secure Shell（安全外壳协议，简称 SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。多应用在远程登录服务器，git拉取与推送，在不是用密码登录的情况下可以通过创建一对ssh私钥与ssh公钥进行免密登录以及git操作。</p><p>创建第一个ssh-key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh                                 #首先先进入ssh目录下</span><br><span class="line">ssh-keygen -t rsa -C &quot;email@gmail.com&quot;    #创建第一个ssh-key</span><br></pre></td></tr></table></figure><p>之后会看见<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/Users/aamen/.ssh/id_rsa): test1   #给要创建的 ssh-key 命名</span><br><span class="line">Enter passphrase (empty for no passphrase):                             #指定密码（空为不指定）</span><br><span class="line">Enter same passphrase again:                                            #重复输入密码</span><br></pre></td></tr></table></figure><br>这就创建完成第一个ssh-key 并且在 ~/.ssh 目录下发现多了两个文件分别是 tes1 和 test1.pub</p><p>再次输入创建新的 ssh-key 并且命名为 test2</p><p>现在 ~/.ssh 目录下有4个文件 分别是 tes1 test1.pub 以及 tes2 和 test2.pub</p><p>然后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim config</span><br></pre></td></tr></table></figure><br>将里面内容修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host github                          # alias名称</span><br><span class="line">HostName github.com                  # host domain 或 ip</span><br><span class="line">Port port-number                     # host 的 SSH port 可不填 默认22</span><br><span class="line">PreferredAuthentications publickey   # 强制使用 Public Key 验证</span><br><span class="line">IdentitiesOnly yes                   # 使用指定的 key</span><br><span class="line">IdentityFile ~/.ssh/test1            # 指定 pem 或 pub 的 key 路径</span><br><span class="line">User username-on-remote-machine      # 登录 SSH 的 username 可不填</span><br></pre></td></tr></table></figure><br>保存并退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq!</span><br></pre></td></tr></table></figure></p><p>测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><br>成功后返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxx! You&apos;ve successfully authenticated, but GitHub does not # provide shell access.</span><br></pre></td></tr></table></figure><br>然后再次修改 config 并添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host gitlab                          # alias名称</span><br><span class="line">HostName gitlab.com                  # host domain 或 ip</span><br><span class="line">Port port-number                     # host 的 SSH port 可不填 默认22</span><br><span class="line">PreferredAuthentications publickey   # 强制使用 Public Key 验证</span><br><span class="line">IdentitiesOnly yes                   # 使用指定的 key</span><br><span class="line">IdentityFile ~/.ssh/test2            # 指定 pem 或 pub 的 key 路径</span><br><span class="line">User username-on-remote-machine      # 登录 SSH 的 username 可不填</span><br></pre></td></tr></table></figure><br>测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh -T git@gitlab.com</span><br><span class="line">Welcome to GitLab, @xxx!</span><br></pre></td></tr></table></figure><br>大功告成~</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker搭建php服务</title>
      <link href="/2018/12/07/nginx%E9%85%8D%E7%BD%AEphp/"/>
      <url>/2018/12/07/nginx%E9%85%8D%E7%BD%AEphp/</url>
      
        <content type="html"><![CDATA[<p>1.登录远端服务器并且下载docker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker</span><br></pre></td></tr></table></figure><br>下载完成后运行 docker info 如果输出docker信息则表示docker安装成功<br> <a id="more"></a><br>安装成功后，拉取nginx、php镜像并查看已有镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx      #拉取nginx镜像</span><br><span class="line">docker pull php:5.6    #拉取php5.6镜像</span><br><span class="line">docker images          #查看已有镜像</span><br></pre></td></tr></table></figure></p><p>镜像拉取成功后，开始构建容器并挂载nginx配置目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p nginx/www nginx/conf #创建nginx目录用来挂载容器www和conf目录</span><br></pre></td></tr></table></figure></p><ul><li>mkdir -p, –parents  可以是一个路径名称。此时若路径中的某些目录尚不存在, 加上此选项后, 系统将自动建立好那些尚不存在的目录, 即一次可以建立多个目录; </li></ul><p>创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#构建php容器</span><br><span class="line">docker run -d -p 9000:9000 -v $PWD/www:/usr/share/nginx/html --name myphpfpm php:5.6-fpm </span><br><span class="line">#构建Nginx容器</span><br><span class="line">docker run -d -p 8080:80 -v $PWD/www:/usr/share/nginx/html --name mynginx --link myphpfpm:phpfpm nginx </span><br><span class="line">docker ps -a      #查看所有已创建的容器 </span><br></pre></td></tr></table></figure><br>查看容器运行状态status，如果创建容器后容器自动退出，先删除容器，再重新用以下命令创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm [CONTAINER ID] #删除容器</span><br><span class="line">docker run -dit -p 9000:9000 -v $PWD/www:/usr/share/nginx/html --name myphpfpm php:5.6-fpm </span><br><span class="line">docker run -dit -p 8080:80 -v $PWD/www:/usr/share/nginx/html --name mynginx --link myphpfpm:phpfpm nginx</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><figcaption><span>docker run -it</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-i: 以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br></pre></td></tr></table></figure><p>创建完容器并且运行成功后配置nginx容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mynginx /bin/bash</span><br><span class="line">vim /etc/nginx/conf.d/default.conf #若无vi 先运行 apt-get update、 apt-get install vim 下载并安装vim</span><br></pre></td></tr></table></figure></p><p>docker exec [OPTIONS] CONTAINER COMMAND [ARG…]<br>-d : 分离模式: 在后台运行<br>-i : 即使没有附加也保持 STDIN 打开<br>-t : 分配一个伪终端</p><p>修改default.conf中php配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">   fastcgi_pass   phpfpm:9000;</span><br><span class="line">   fastcgi_index  index.php;</span><br><span class="line">   fastcgi_param  SCRIPT_FILENAME  /usr/share/nginx/html$fastcgi_script_name;</span><br><span class="line">   fastcgi_param  SCRIPT_NAME      $fastcgi_script_name;</span><br><span class="line">   include        fastcgi_params;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//重新加载nginx配置并生效后退出容器 </span><br><span class="line">//nginx -s reload</span><br><span class="line">//exit</span><br></pre></td></tr></table></figure><br>重启nginx并退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service nginx restart</span><br><span class="line">docker restart mynginx</span><br></pre></td></tr></table></figure><br>安装数据库扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec  -it myphpfpm /bin/bash</span><br><span class="line">docker-php-ext-install bcmath dba exif mysqli pdo_mysql sysvsem sysvshm </span><br></pre></td></tr></table></figure><br>安装redis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec  -it myphpfpm /bin/bash</span><br><span class="line">pecl install redis &amp;&amp; docker-php-ext-enable redis</span><br></pre></td></tr></table></figure><br>安装pecl扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Install PECL extensions</span><br><span class="line">$ apt-get install -y \</span><br><span class="line"></span><br><span class="line">    // for memcache</span><br><span class="line">    libmemcache-dev \</span><br><span class="line"></span><br><span class="line">    // for memcached</span><br><span class="line">    libmemcached-dev \</span><br><span class="line"></span><br><span class="line">    &amp;&amp; pecl install memcache &amp;&amp; docker-php-ext-enable memcache \</span><br><span class="line">    &amp;&amp; pecl install memcached &amp;&amp; docker-php-ext-enable memcached \</span><br><span class="line">    &amp;&amp; pecl install gearman &amp;&amp; docker-php-ext-enable gearman \</span><br><span class="line">    &amp;&amp; pecl install xdebug &amp;&amp; docker-php-ext-enable xdebug \</span><br><span class="line">    &amp;&amp; pecl install redis &amp;&amp; docker-php-ext-enable redis \</span><br><span class="line">    &amp;&amp; pecl install xhprof &amp;&amp; docker-php-ext-enable xhprof </span><br></pre></td></tr></table></figure></p><p>安装php x-cache 扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL &apos;https://xcache.lighttpd.net/pub/Releases/3.2.0/xcache-3.2.0.tar.gz&apos; -o xcache.tar.gz \</span><br><span class="line">     &amp;&amp; mkdir -p xcache \</span><br><span class="line">     &amp;&amp; tar -xf xcache.tar.gz -C xcache --strip-components=1 \</span><br><span class="line">     &amp;&amp; rm xcache.tar.gz \</span><br><span class="line">     &amp;&amp; ( \</span><br><span class="line">         cd xcache \</span><br><span class="line">         &amp;&amp; phpize \</span><br><span class="line">         &amp;&amp; ./configure --enable-xcache \</span><br><span class="line">         &amp;&amp; make -j$(nproc) \</span><br><span class="line">         &amp;&amp; make install \</span><br><span class="line">     ) \</span><br><span class="line">     &amp;&amp; rm -r xcache \</span><br><span class="line">     &amp;&amp; docker-php-ext-enable xcache</span><br></pre></td></tr></table></figure><br>安装完之后退出myphpfpm容器并重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart myphpfpm</span><br></pre></td></tr></table></figure></p><p>重启后查看phpinfo发现x-cache已工作</p><p>容器的保存、导出与导入</p><p>先将生成好的容器创建为镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker commit myphpfpm myphpfpm_img</span><br><span class="line">docker commit mynginx  mynginx_img</span><br></pre></td></tr></table></figure><br>保存指定镜像为tar文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images #查看生成好的镜像id</span><br><span class="line">docker save [IMAGE ID] &gt; xxx.tar</span><br></pre></td></tr></table></figure><br>保存成功之后 先让我们删除之前创建的所有容器以及镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -aq)</span><br><span class="line">docker rm $(docker ps -aq)</span><br><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><br>加载image<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; xxx.tar #之前生成的image压缩文件</span><br></pre></td></tr></table></figure><br>加载成功后标记本地镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker tag [IMAGE ID] xxx:1</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
