<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>kafka伪集群搭建</title>
      <link href="/2020/03/29/kafka%E4%BC%AA%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/03/29/kafka%E4%BC%AA%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>一、安装java环境，不再赘述。</p><p>二、下载kafka安装包</p><p>　　<a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a></p><p>　　选择 kafka-2.10-0.10.2.0.tgz 下载</p><p>三、搭建集群</p><p>3.1在/opt目录下创建kafka/目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/kafka</span><br></pre></td></tr></table></figure><p>3.2将下载的 kafka-2.10-0.10.2.0.tgz 放到 /opt/kafka/ 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/kafka</span><br><span class="line">tar -zxvf kafka-2.10-0.10.2.0.tgz</span><br></pre></td></tr></table></figure><p>3.3创建kafka日志目录，这里我创建的伪集群有三台服务器，所以创建三个日志目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/kafka/kafkalogs1 kafkalogs2 kafkalogs3</span><br></pre></td></tr></table></figure><p>3.4进入kafka-2.10-0.10.2.0.tgz的解压出来的 conf/ 目录，修改配置文件，同样集群的三台服务器分别对应一个配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/kafka/kafka_2.10-0.10.2.0/config</span><br><span class="line">cp server.properties server.properties1</span><br><span class="line">cp server.properties server.properties2</span><br><span class="line">cp server.properties server.properties3</span><br></pre></td></tr></table></figure><p>修改server.properties1、2、3，主要修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server.properties1:</span><br><span class="line">  broker.id=0</span><br><span class="line">  host.name=192.168.10.130</span><br><span class="line">  port=9092</span><br><span class="line">  log.dirs=/opt/kafka/kafkalogs1</span><br><span class="line">  zookeeper.connect=192.168.10.130:2181,192.168.10.130:2182,192.168.10.130:2183</span><br><span class="line">server.properties2:</span><br><span class="line">  broker.id=1</span><br><span class="line">  host.name=192.168.10.128</span><br><span class="line">  port=9093</span><br><span class="line">  log.dirs=/opt/kafka/kafkalogs2</span><br><span class="line">  zookeeper.connect=192.168.10.130:2181,192.168.10.130:2182,192.168.10.130:2183</span><br><span class="line">server.properties3:</span><br><span class="line">  broker.id=2</span><br><span class="line">  host.name=192.168.10.128</span><br><span class="line">  port=9094</span><br><span class="line">  log.dirs=/opt/kafka/kafkalogs3</span><br><span class="line">  zookeeper.connect=192.168.10.130:2181,192.168.10.130:2182,192.168.10.130:2183</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>配置文件解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">broker.id=0  #当前机器在集群中的唯一标识，和zookeeper的myid性质一样</span><br><span class="line">port=9092 #当前kafka对外提供服务的端口默认是9092</span><br><span class="line">host.name=192.168.10.130#这个参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题。</span><br><span class="line">num.network.threads=3 #这个是borker进行网络处理的线程数</span><br><span class="line">num.io.threads=8 #这个是borker进行I/O处理的线程数</span><br><span class="line">log.dirs=/opt/kafka/kafkalogs/ #消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个</span><br><span class="line">socket.send.buffer.bytes=102400 #发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能</span><br><span class="line">socket.receive.buffer.bytes=102400 #kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘</span><br><span class="line">socket.request.max.bytes=104857600 #这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小</span><br><span class="line">num.partitions=1 #默认的分区数，一个topic默认1个分区数</span><br><span class="line">log.retention.hours=168 #默认消息的最大持久化时间，168小时，7天</span><br><span class="line">message.max.byte=5242880  #消息保存的最大值5M</span><br><span class="line">default.replication.factor=2  #kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务</span><br><span class="line">replica.fetch.max.bytes=5242880  #取消息的最大直接数</span><br><span class="line">log.segment.bytes=1073741824 #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件</span><br><span class="line">log.retention.check.interval.ms=300000 #每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除</span><br><span class="line">log.cleaner.enable=false #是否启用log压缩，一般不用启用，启用的话可以提高性能</span><br><span class="line">zookeeper.connect=192.168.10.130:2181,192.168.10.130:2182,192.168.10.130:2183  #设置zookeeper的连接端口</span><br><span class="line">zookeeper.connection.timeout.ms=6000  #zookeeper的session的过期时间</span><br><span class="line">zookeeper.sync.time.ms=2000  #指定多久消费者更新offset到zookeeper中</span><br><span class="line">group.id=test-consumer-group #(必需)consumer组id</span><br><span class="line">consumer.timeout.ms=5000　　#消费者超时</span><br><span class="line">auto.commit.enable=true #自动向zookeeper提交offset信息</span><br><span class="line">auto.commit.interval.ms=1000  #自动更新时间</span><br><span class="line">#consumer.id=xxx   #当前consumer的标识,如果不设置会自动生成</span><br></pre></td></tr></table></figure><p>四、启动kafka前修改启动脚本 bin/kafka-server-start.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将 export KAFKA_HEAP_OPTS=&quot;-Xmx1G-Xms1G&quot;</span><br><span class="line">改为 export KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms128M&quot;</span><br></pre></td></tr></table></figure><p>五、启动kafka</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/kafka/kafka_2.10-0.10.2.0</span><br><span class="line">bin/kafka-server-start.sh config/server.properties1</span><br><span class="line">bin/kafka-server-start.sh config/server.properties2</span><br><span class="line">bin/kafka-server-start.sh config/server.properties3</span><br></pre></td></tr></table></figure><p>当看到终端输出“[Kafka Server 0], started (kafka.server.KafkaServer)”等相关信息时，说明kafka集群启动成功。</p><p>六、创建topic验证是否创建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#创建Topic</span><br><span class="line">bin/kafka-topics.sh --create --zookeeper zookeeper_node:2181 --replication-factor 2 --partitions 1 --topic test</span><br><span class="line">#解释</span><br><span class="line">partitions指定topic分区数，replication-factor指定topic每个分区的副本数</span><br><span class="line">partitions分区数:</span><br><span class="line">　　partitions ：分区数，控制topic将分片成多少个log。可以显示指定，如果不指定则会使用broker(server.properties)中的num.partitions配置的数量,</span><br><span class="line">虽然增加分区数可以提供kafka集群的吞吐量、但是过多的分区数或者或是单台服务器上的分区数过多，会增加不可用及延迟的风险。因为多的分区数，意味着需要打开更</span><br><span class="line">多的文件句柄、增加点到点的延时、增加客户端的内存消耗。分区数也限制了consumer的并行度，即限制了并行consumer消息的线程数不能大于分区数,分区数也限制了</span><br><span class="line">producer发送消息是指定的分区。如创建topic时分区设置为1，producer发送消息时通过自定义的分区方法指定分区为2或以上的数都会出错的；这种情况可以通过</span><br><span class="line">alter –partitions 来增加分区数。</span><br><span class="line">replication-factor副本</span><br><span class="line">　　replication factor 控制消息保存在几个broker(服务器)上，一般情况下等于broker的个数。</span><br><span class="line">　　如果没有在创建时显示指定或通过API向一个不存在的topic生产消息时会使用broker(server.properties)中的default.replication.factor配置的数量</span><br><span class="line">#在控制台上创建一个发布者</span><br><span class="line">bin/kafka-console-producer.sh --broker-list kafka_node:9092 --topic test</span><br><span class="line"></span><br><span class="line">#在控制台创建一个消费者</span><br><span class="line">bin/kafka-console-consumer.sh --zookeeper zookeeper_node:2181 --topic test --from-beginning</span><br></pre></td></tr></table></figure><p> 七、其他命令</p><p>7.1、查看topic</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper zookeeper_node:2181</span><br><span class="line">#就会显示我们创建的所有topic</span><br></pre></td></tr></table></figure><p>7.2、查看topic状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper zookeeper_node:12181 --topic test</span><br><span class="line">#下面是显示信息</span><br><span class="line">Topic:ssports    PartitionCount:1    ReplicationFactor:2    Configs:</span><br><span class="line">Topic: test      Partition: 0    Leader: 1    Replicas: 0,1    Isr: 1</span><br><span class="line">#分区为为1  复制因子为2   他的  shuaige的分区为0 </span><br><span class="line">#Replicas: 0,1   复制的为0，1</span><br></pre></td></tr></table></figure><p>7.3、增加Topic分区数</p><p>　　为test增加分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper zookeeper_node:2181  --alter --topic test --partitions 10</span><br></pre></td></tr></table></figure><p>7.4、删除Topic</p><p>　　只会删除zookeeper中的元数据，消息文件需要自己删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-run-class.sh kafka.admin.DeleteTopicCommand --zookeeper zookeeper_node:2181 --topic test</span><br></pre></td></tr></table></figure><p>7.5、查看Topic消费进度</p><p>　　这个会显示出consumer group的offset情况， 必须参数为–group， 不指定–topic，默认为所有topic</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-run-class.sh kafka.tools.ConsumerOffsetChecker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>zkWatcher</title>
      <link href="/2020/03/20/zkWatcher/"/>
      <url>/2020/03/20/zkWatcher/</url>
      
        <content type="html"><![CDATA[<p>直接上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">package aamen.test.zookeeperTest;</span><br><span class="line"></span><br><span class="line">import org.apache.zookeeper.*;</span><br><span class="line">import org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">import org.apache.zookeeper.ZooDefs.Ids;</span><br><span class="line">import org.apache.zookeeper.Watcher.Event.EventType;</span><br><span class="line">import org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author aamen</span><br><span class="line"> * @Title:</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Version:</span><br><span class="line"> * @date 2020/3/19 6:32 下午</span><br><span class="line"> */</span><br><span class="line">public class DemoWatcher implements Watcher &#123;</span><br><span class="line">    private ZooKeeper zookeeper;</span><br><span class="line">    private static final String CONNECT_PATH = &quot;118.190.40.252:2181,118.190.40.252:2182,118.190.40.252:2183&quot;;</span><br><span class="line"></span><br><span class="line">    // 超时时间</span><br><span class="line">    private static final int SESSION_TIME_OUT = 20000;</span><br><span class="line"></span><br><span class="line">    private static final CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">    private ZooKeeper zk = null;</span><br><span class="line"></span><br><span class="line">    //用来计数，判断调用了几次watcher方法</span><br><span class="line">    private static final AtomicInteger cnt = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    //设定编码</span><br><span class="line">    private static final Charset CHARSET = Charset.forName(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        DemoWatcher demo = new DemoWatcher();</span><br><span class="line"></span><br><span class="line">        //获取连接</span><br><span class="line">        demo.createConnection(CONNECT_PATH, SESSION_TIME_OUT);</span><br><span class="line"></span><br><span class="line">        //睡眠</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        //使用默认的watcher, watcher只执行一次，不是一直执行 ，exists 没有触发事件</span><br><span class="line">        Stat stat = demo.zk.exists(&quot;/watcher&quot;, true);</span><br><span class="line">        if (stat == null) &#123;</span><br><span class="line">            String path = demo.zk.create(&quot;/watcher&quot;, //节点</span><br><span class="line">                    &quot;watcher&quot;.getBytes(CHARSET), //节点内容</span><br><span class="line">                    Ids.OPEN_ACL_UNSAFE, //所有热都可以访问</span><br><span class="line">                    CreateMode.EPHEMERAL); //临时节点</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //更新了数据，而且设定了监听watch</span><br><span class="line">        demo.zk.exists(&quot;/watcher&quot;, true);</span><br><span class="line">//        demo.zk.setData(&quot;/watcher&quot;, &quot;update&quot;.getBytes(), -1);</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设定watcher处理的方法</span><br><span class="line">     */</span><br><span class="line">    public void process(WatchedEvent event) &#123;</span><br><span class="line">        if (event == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        KeeperState state = event.getState();</span><br><span class="line">        EventType type = event.getType();</span><br><span class="line"></span><br><span class="line">        //受影响的节点</span><br><span class="line">        String path = event.getPath();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------Watcher调用次数\t&quot; + cnt.incrementAndGet() + &quot;---------------------&quot;);</span><br><span class="line">        System.out.println(&quot;path\t&quot; + path);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;状态\t&quot; + state);</span><br><span class="line">        System.out.println(&quot;事件类型\t&quot; + type);</span><br><span class="line">        //判断是否连接了</span><br><span class="line">        if (state == KeeperState.SyncConnected) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            switch (event.getType()) &#123;</span><br><span class="line">                case None:</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    System.out.println(&quot;事件\t连接成功&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                case NodeCreated:</span><br><span class="line">                    System.out.println(&quot;事件\t节点创建&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                case NodeChildrenChanged:</span><br><span class="line">                    System.out.println(&quot;事件\t节点创建&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                case NodeDeleted:</span><br><span class="line">                    System.out.println(&quot;事件\t节点删除&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                case NodeDataChanged:</span><br><span class="line">                    System.out.println(&quot;事件\t节点变更&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//        节点发生变化之后重新监听</span><br><span class="line">        try &#123;</span><br><span class="line">            this.zk.exists(&quot;/watcher&quot;, true);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void createConnection(String path, int timeOut) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //关闭连接</span><br><span class="line">            this.closeConnection();</span><br><span class="line"></span><br><span class="line">            //获取连接，设定监听的Watch</span><br><span class="line">            zk = new ZooKeeper(path, timeOut, this);</span><br><span class="line"></span><br><span class="line">            //等待</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关闭连接</span><br><span class="line">     * 创建日期:2017年10月14日&lt;br/&gt;</span><br><span class="line">     * 创建用户:yellowcong&lt;br/&gt;</span><br><span class="line">     * 功能描述:</span><br><span class="line">     */</span><br><span class="line">    public void closeConnection() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (zk != null) &#123;</span><br><span class="line">                zk.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>zk伪分布式搭建</title>
      <link href="/2020/03/20/zk%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/03/20/zk%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>一、描述<br>伪分布式集群就是在一台机器部署多个zk应用，部署之前服务器需要有jdk环境 java -version可以显示相关java信息才可以进行zookeeper搭建<br>二、步骤<br>第一步下载好zookeeper-3.4.9.tar.gz<br>然后解压tar zxvf zookeeper-3.4.9.tar.gz</p><p>进入zk中的conf目录下输入cp zoo-sample.cfg zoo1.cfg  cp zoo-sample.cfg zoo2.cfg、cp zoo-sample.cfg zoo3.cfg<br>分别对zoo1、2、3文件进行编辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir=/apps/servers/data/d_1</span><br><span class="line">dataLogDir=/apps/servers/logs/logs_1</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181 </span><br><span class="line">#不同zoo.cfg修改自己的属性和端口号</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br><span class="line">server.1=localhost:2187:2887 </span><br><span class="line">server.2=localhost:2188:2888</span><br><span class="line">server.3=localhost:2189:2889</span><br></pre></td></tr></table></figure></p><p>修改之后分别创建data目录和日志目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir /apps/servers/data/d_1</span><br><span class="line">mkdir /apps/servers/data/d_1</span><br><span class="line">mkdir /apps/servers/data/d_1</span><br><span class="line"></span><br><span class="line">mkdir /apps/servers/logs/logs_1</span><br><span class="line">mkdir /apps/servers/logs/logs_1</span><br><span class="line">mkdir /apps/servers/logs/logs_1</span><br><span class="line"></span><br><span class="line">echo &quot;1&quot; &gt; /apps/servers/data/d_1/myid</span><br><span class="line">echo &quot;2&quot; &gt;/apps/servers/data/d_2/myid</span><br><span class="line">echo &quot;3&quot; &gt;/apps/servers/data/d_3/myid</span><br></pre></td></tr></table></figure><br>进入bin目录下输入命令 分别进行启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start ../conf/zoo1.cfg</span><br><span class="line">zkServer.sh start ../conf/zoo2.cfg</span><br><span class="line">zkServer.sh start ../conf/zoo3.cfg</span><br></pre></td></tr></table></figure><br>通过命令检测是否成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkCli.sh -server localhost:2181, localhost:2182, localhost:2183 是否可以连接成功</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java虚拟机及内存模型</title>
      <link href="/2019/12/11/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/12/11/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>面试题</p><p>JVM运行内存的分类<br>程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有<br>注：如果正在执行的是Native方法，计数器值则为空<br>Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有<br>Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有<br>Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享<br>方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享<br>Java内存堆和栈区别<br>栈内存用来存储基本类型的变量和对象的引用变量，堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中<br>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问<br>如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError，如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError<br>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满，-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小<br>Java四引用<br>强引用（StrongReference）强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题<br>软引用（SoftReference）<br>如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中<br>弱引用（WeakReference）<br>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中<br>虚引用（PhantomReference）<br>虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br>GC回收机制<br>Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控<br>Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理<br>可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用<br>GC 标记对象的死活<br>引用计数法：给对象添加一个引用计数器,没当被引用的时候,计数器的值就加一。引用失效的时候减一,当计数器的值为 0 的时候就表示改对象可以被 GC 回收了，弊端:A-&gt;B,B-&gt;A,那么 AB 将永远不会被回收了。也就是引用有环的情况<br>根搜索算法(可达性算法) GC Roots Tracing：通过一个叫 GC Roots 的对象作为起点,从这些结点开始向下搜索,搜索所走过的路径称为引用链,当一个对象没有与任何的引用链相连的时候则改对象就可以被。 GC 回收回收了Roots 包括：java 虚拟机栈中引用的对象,本地方法栈中引用的对象,方法区中常量引用的对象,方法区中静态属性引用的对象<br>在Java语言里，可作为GC Roots的对象包括以下几种：<br> 虚拟机栈（栈帧中的本地变量表）中的引用的对象<br> 方法区中的类静态属性引用的对象<br> 方法区中的常量引用的对象。<br> 本地方法栈中JNI(即一般说的Native方法)的引用的对象。<br>GC回收算法<br>标记-清除法：标记出没有用的对象，然后一个一个回收掉<br>缺点：标记和清除两个过程效率不高，产生内存碎片导致需要分配较大对象时无法找到足够的连续内存而需要触发一次GC操作<br>复制算法: 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉<br>缺点：将内存缩小为了原来的一半<br>标记-整理法：标记出没有用的对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内<br>优点：解决了标记- 清除算法导致的内存碎片问题和在存活率较高时复制算法效率低的问题。<br>分代回收：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法<br>MinorGC&amp;FullGC<br>Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快，一般采用复制-回收算法<br>Full GC/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，所采用的是标记-清除算法<br>内存分配与回收策略<br>结构（堆大小 = 新生代 + 老年代 ）：<br>新生代(1/3)(初始对象，生命周期短)：Eden 区、survivior 0、survivior 1（ 8 : 1 : 1）<br>老年代(2/3)(长时间存在的对象)<br>一般小型的对象都会在 Eden 区上分配，如果Eden区无法分配，那么尝试把活着的对象放到survivor0中去（Minor GC）<br>如果survivor0可以放入，那么放入之后清除Eden区<br>如果survivor0不可以放入，那么尝试把Eden和survivor0的存活对象放到survivor1中<br>如果survivor1可以放入，那么放入survivor1之后清除Eden和survivor0，之后再把survivor1中的对象复制到survivor0中，保持survivor1一直为空。<br>如果survivor1不可以放入，那么直接把它们放入到老年代中，并清除Eden和survivor0，这个过程也称为分配担保（Full GC）<br>大对象、长期存活的对象则直接进入老年代<br>动态对象年龄判定<br>空间分配担保，Full GC…<br>GC垃圾收集器<br>Serial New收集器是针对新生代的收集器，采用的是复制算法<br>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理<br>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法<br>Serial Old（串行）收集器，新生代采用复制，老年代采用标记清理<br>Parallel Old（并行）收集器，针对老年代，标记整理<br>CMS收集器，基于标记清理<br>G1收集器(JDK)：整体上是基于标记清理，局部采用复制<br>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理<br>Java类加载机制<br>概念：<br>虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型（java.lang.Class对象）<br>类的生命周期：<br>加载过程：通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；<br>验证过程：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，文件格式验证、元数据验证、字节码验证、符号引用验证<br>准备过程：正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在方法区中进行分配<br>解析阶段：虚拟机将常量池内的符号引用替换为直接引用的过程<br>初始化阶段：类初始化阶段是类加载过程的最后一步。初始化阶段就是执行类构造器<clint>()方法的过程<br>使用阶段：<br>卸载阶段：<br>Java类加载器：<br>类加载器负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次<br>Bootstrap ClassLoader:根类加载器，负责加载java的核心类，它不是java.lang.ClassLoader的子类，而是由JVM自身实现<br>Extension ClassLoader:扩展类加载器，扩展类加载器的加载路径是JDK目录下jre/lib/ext,扩展类的getParent()方法返回null,实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是Java实现的<br>System ClassLoader:系统(应用)类加载器，它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性或CLASSPATH环境变量所指定的jar包和类路径。程序可以通过getSystemClassLoader()来获取系统类加载器。系统加载器的加载路径是程序运行的当前路径<br>双亲委派模型的工作过程：<br>首先会先查找当前ClassLoader是否加载过此类，有就返回；<br>如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类；<br>如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)，整个过程类似循环链表一样。<br>双亲委托机制的作用：<br>共享功能：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。<br>隔离功能：因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器，保证java/Android核心类库的纯净和安全，防止恶意加载。<br>如何打破双亲委派模型？<br>双亲委派模型的逻辑都在loadClass()中，重写loaderClass()，一般是重写findClass()的<br>系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载<br>自定义ClassLoader：<br>loadClass(String name,boolean resolve)：根据指定的二进制名称加载类<br>findClass(String name)： 根据二进制名称来查找类<br>直接使用或继承已有的ClassLoader实现：java.net.URLClassLoader、java.security.SecureClassLoader、 java.rmi.server.RMIClassLoader<br>在调用loadClass()，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载<br>引起类加载操作的五个行为<br>遇到new、getstatic、putstatic或invokestatic这四条字节码指令<br>反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化<br>子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化<br>虚拟机执行主类的时候(有 main(string[] args))<br>JDK1.7 动态语言支持<br>Java对象创建时机<br>使用new关键字创建对象<br>使用Class类的newInstance方法(反射机制)<br>使用Constructor类的newInstance方法(反射机制)<br>使用Clone方法创建对象<br>使用(反)序列化机制创建对象</clint></p><p>  程序计数器（Program Counter Register）<br>    一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。</p><pre><code>当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中么有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。</code></pre><p>   Java虚拟机栈（Java Virtual Machine Stacks）<br>   该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p><pre><code>1、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。2、如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。这两种情况存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。而在多线程环境下，则会抛出OutOfMemoryError异常。下面详细说明栈帧中所存放的各部分信息的作用和数据结构。 </code></pre><p>   1、局部变量表</p><p>   局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和returnAddress类型（它指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，即在Java程序被编译成Class文件时，就确定了所需分配的最大局部变量表的容量。当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><pre><code>局部变量表的容量以变量槽（Slot）为最小单位。在虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小（允许其随着处理器、操作系统或虚拟机的不同而发生变化），一个Slot可以存放一个32位以内的数据类型：boolean、byte、char、short、int、float、reference和returnAddresss。reference是对象的引用类型，returnAddress是为字节指令服务的，它执行了一条字节码指令的地址。对于64位的数据类型（long和double），虚拟机会以高位在前的方式为其分配两个连续的Slot空间。虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始到局部变量表最大的Slot数量，对于32位数据类型的变量，索引n代表第n个Slot，对于64位的，索引n代表第n和第n+1两个Slot。在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），则局部变量表中的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。其余参数则按照参数表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用。这样的设计不仅仅是为了节省空间，在某些情况下Slot的复用会直接影响到系统的而垃圾收集行为。2、操作数栈操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。32位数据类型所占的栈容量为1,64为数据类型所占的栈容量为2。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。因此我们也称Java虚拟机是基于栈的，这点不同于Android虚拟机，Android虚拟机是基于寄存器的。基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差。3、动态连接每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。4、方法返回地址当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。</code></pre><p>   本地方法栈（Native Method Stacks）<br>    该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。</p><p>   Java堆（Java Heap）<br>    Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</p><pre><code>根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。   </code></pre><p>   方法区（Method Area）<br>    方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”，但这仅仅对于Sun HotSpot来讲，JRockit和IBM J9虚拟机中并不存在永久代的概念。Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，而且它和Java Heap一样不需要连续的内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。相对而言，垃圾收集行为在这个区域比较少出现。该区域的内存回收目标主要针是对废弃常量的和无用类的回收。运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern（）方法。</p><pre><code>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。直接内存（Direct Memory）</code></pre><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受Java堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致OutOfMemoryError异常出现。在JDK1.4中新引入了NIO机制，它是一种基于通道与缓冲区的新I/O方式，可以直接从操作系统中分配直接内存，即在堆外分配内存，这样能在一些场景中提高性能，因为避免了在Java堆和Native堆中来回复制数据。关于NIO的详细使用可以参考我的Java网络编程系列中关于NIO的相关文章。<br>————————————————<br>版权声明：本文为CSDN博主「linghu_java」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/linghu_java/article/details/51149889" target="_blank" rel="noopener">https://blog.csdn.net/linghu_java/article/details/51149889</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java多线程面试题</title>
      <link href="/2019/12/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/12/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>1、说说进程,线程,协程之间的区别</p><p>简而言之,进程是程序运行和资源分配的基本单位,一个程序至少有一个进程,一个进程至少有一个线程.进程在执行过程中拥有独立的内存单元,而多个线程共享内存资源,减少切换次数,从而效率更高.线程是进程的一个实体,是cpu调度和分派的基本单位,是比程序更小的能独立运行的基本单位.同一进程中的多个线程之间可以并发执行.</p><p>2、你了解守护线程吗?它和非守护线程有什么区别<br>程序运行完毕,jvm会等待非守护线程完成后关闭,但是jvm不会等待守护线程.守护线程最典型的例子就是GC线程</p><p>3、什么是多线程上下文切换<br>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><p>4、创建两种线程的方式?他们有什么区别?<br>通过实现java.lang.Runnable或者通过扩展java.lang.Thread类.相比扩展Thread,实现Runnable接口可能更优.原因有二:<br>Java不支持多继承.因此扩展Thread类就代表这个子类不能扩展其他类.而实现Runnable接口的类还可能扩展另一个类.<br>类可能只要求可执行即可,因此继承整个Thread类的开销过大.</p><p>5、Thread类中的start()和run()方法有什么区别?<br>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p><p>6、怎么检测一个线程是否持有对象监视器<br>Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。</p><p>7、Runnable和Callable的区别<br>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。<br>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以方便获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务</p><p>8、什么导致线程阻塞<br>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p><p>方法说明</p><p>sleep()<br>sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止</p><p>suspend() 和 resume()<br>两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</p><p>yield()<br>yield() 使当前线程放弃当前已经分得的CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程</p><p>wait() 和 notify()<br>两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</p><p>9、wait(),notify()和suspend(),resume()之间的区别<br>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。<br>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致从调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。<br>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。<br>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized关键字一起使用，将它们和操作系统进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。<br>关于 wait() 和 notify() 方法最后再说明两点：<br>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。<br>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。<br>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。<br>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p><p>11、产生死锁的条件<br>1.互斥条件：一个资源每次只能被一个进程使用。<br>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>12、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用<br>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁<br>wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别<br>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p><p>13、wait()与sleep()的区别<br>关于这两者已经在上面进行详细的说明,这里就做个概括好了:<br>sleep()来自Thread类，和wait()来自Object类.调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁<br>sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU<br>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒.而wait()需要配合notify()或者notifyAll()使用</p><p>14、为什么wait,nofity和nofityAll这些方法不放在Thread类当中<br>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><p>15、怎么唤醒一个阻塞的线程<br>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><p>16、什么是多线程的上下文切换<br>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><p>17、synchronized和ReentrantLock的区别<br>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：<br>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁<br>（2）ReentrantLock可以获取各种锁的信息<br>（3）ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word.</p><p>18、FutureTask是什么<br>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><p>19、一个线程如果出现了运行时异常怎么办?<br>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p><p>20、Java当中有哪几种锁<br>自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定</p><p>偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。</p><p>轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁</p><p>21、如何在两个线程间共享数据<br>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><p>22、如何正确的使用wait()?使用if还是while?<br>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：<br>synchronized (obj) {<br>   while (condition does not hold)<br>     obj.wait(); // (Releases lock, and reacquires on wakeup)<br>     … // Perform action appropriate to condition<br>}</p><p>23、什么是线程局部变量ThreadLocal<br>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><p>24、ThreadLoal的作用是什么?<br>简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了.</p><p>25、生产者消费者模型的作用是什么?<br>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用<br>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p><p>26.写一个生产者-消费者队列<br>可以通过阻塞队列实现,也可以通过wait-notify来实现.<br>使用阻塞队列来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//消费者</span><br><span class="line">public class Producer implements Runnable&#123;</span><br><span class="line">   private final BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">   public Producer(BlockingQueue q)&#123;</span><br><span class="line">       this.queue=q;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           while (true)&#123;</span><br><span class="line">               Thread.sleep(1000);//模拟耗时</span><br><span class="line">               queue.put(produce());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private int produce() &#123;</span><br><span class="line">       int n=new Random().nextInt(10000);</span><br><span class="line">       System.out.println(&quot;Thread:&quot; + Thread.currentThread().getId() + &quot; produce:&quot; + n);</span><br><span class="line">       return n;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">//消费者</span><br><span class="line">public class Consumer implements Runnable &#123;</span><br><span class="line">   private final BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">   public Consumer(BlockingQueue q)&#123;</span><br><span class="line">       this.queue=q;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       while (true)&#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               Thread.sleep(2000);//模拟耗时</span><br><span class="line">               consume(queue.take());</span><br><span class="line">           &#125;catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void consume(Integer n) &#123;</span><br><span class="line">       System.out.println(&quot;Thread:&quot; + Thread.currentThread().getId() + &quot; consume:&quot; + n);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       BlockingQueue&lt;Integer&gt; queue=new ArrayBlockingQueue&lt;Integer&gt;(100);</span><br><span class="line">       Producer p=new Producer(queue);</span><br><span class="line">       Consumer c1=new Consumer(queue);</span><br><span class="line">       Consumer c2=new Consumer(queue);</span><br><span class="line"></span><br><span class="line">       new Thread(p).start();</span><br><span class="line">       new Thread(c1).start();</span><br><span class="line">       new Thread(c2).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用wait-notify来实现<br>该种方式应该最经典,这里就不做说明了</p><p>27、如果你提交任务时，线程池队列已满，这时会发生什么<br>如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</p><p>28、为什么要使用线程池<br>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><p>29、java中用到的线程调度算法是什么<br>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><p>30、Thread.sleep(0)的作用是什么<br>由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><p>31、什么是CAS<br>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功</p><p>32、什么是乐观锁和悲观锁<br>乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。<br>悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><p>33、ConcurrentHashMap的并发度是什么?<br>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><p>34、ConcurrentHashMap的工作原理<br>ConcurrentHashMap在jdk 1.6和jdk 1.8实现原理是不同的.<br>jdk 1.6:<br>ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。<br>具体实现:ConcurrentHashMap内部有一个Segment<br>jdk 1.8<br>在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。</p><p>37、CyclicBarrier和CountDownLatch区别<br>这两个类非常类似，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><p>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p><p>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p><p>39、java中的++操作符线程安全么?<br>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差</p><p>40、你有哪些多线程开发良好的实践?<br>给线程命名<br>最小化同步范围<br>优先使用volatile<br>尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore</p><p>优先使用并发容器而非同步容器.</p><p>考虑使用线程池</p><p>关于volatile关键字</p><p>1、可以创建Volatile数组吗?</p><p>Java 中可以创建 volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到volatile 的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了</p><p>2、volatile能使得一个非原子操作变成原子操作吗?</p><p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。<br>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p><p>3、volatile类型变量提供什么保证?</p><p>volatile 主要有两方面的作用:1.避免指令重排2.可见性保证.例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的.</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java io nio面试题</title>
      <link href="/2019/12/11/java%20io%20nio%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/12/11/java%20io%20nio%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>一 Java NIO 概览<br>主要内容:</p><p>NIO简介:<br>Java NIO 是 java 1.4, 之后新出的一套IO接口NIO中的N可以理解为Non-blocking，不单纯是New。</p><p>NIO的特性/NIO与IO区别:</p><p>1)IO是面向流的，NIO是面向缓冲区的；<br>2)IO流是阻塞的，NIO流是不阻塞的;<br>3)NIO有选择器，而IO没有。</p><p>读数据和写数据方式:<br>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。<br>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</p><p>NIO核心组件简单介绍<br>Channels<br>Buffers<br>Selectors</p><p>二 Java NIO 之 Buffer(缓冲区)<br>主要内容:<br>Buffer(缓冲区)介绍:</p><p>Java NIO Buffers用于和NIO Channel交互。 我们从Channel中读取数据到buffers里，从Buffer把数据写入到Channels；<br>Buffer本质上就是一块内存区；<br>一个Buffer有三个属性是必须掌握的，分别是：capacity容量、position位置、limit限制。</p><p>Buffer的常见方法</p><p>Buffer clear()<br>Buffer flip()<br>Buffer rewind()<br>Buffer position(int newPosition)</p><p>Buffer的使用方式/方法介绍:</p><p>分配缓冲区（Allocating a Buffer）:</p><p>ByteBuffer buf = ByteBuffer.allocate(28);//以ByteBuffer为例子</p><p>写入数据到缓冲区（Writing Data to a Buffer）</p><p>写数据到Buffer有两种方法：<br>1.从Channel中写数据到Buffer<br>int bytesRead = inChannel.read(buf); //read into buffer.<br>2.通过put写数据：<br>buf.put(127);</p><p>Buffer常用方法测试<br>说实话，NIO编程真的难，通过后面这个测试例子，你可能才能勉强理解前面说的Buffer方法的作用。</p><p>三 Java NIO 之 Channel（通道）<br>主要内容:</p><p>Channel（通道）介绍</p><p>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。<br>NIO Channel通道和流的区别：</p><p>FileChannel的使用<br>SocketChannel和ServerSocketChannel的使用<br>️DatagramChannel的使用<br>Scatter / Gather</p><p>Scatter: 从一个Channel读取的信息分散到N个缓冲区中(Buufer).<br>Gather: 将N个Buffer里面内容按照顺序发送到一个Channel.</p><p>通道之间的数据传输</p><p>在Java NIO中如果一个channel是FileChannel类型的，那么他可以直接把数据传输到另一个channel。<br>transferFrom() :transferFrom方法把数据从通道源传输到FileChannel<br>transferTo() :transferTo方法把FileChannel数据传输到另一个channel</p><p>四 Java NIO之Selector（选择器）<br>主要内容:</p><p>Selector（选择器）介绍</p><p>Selector 一般称 为选择器 ，当然你也可以翻译为 多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。<br>使用Selector的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。</p><p>Selector（选择器）的使用方法介绍</p><p>Selector的创建</p><p>Selector selector = Selector.open();</p><p>注册Channel到Selector(Channel必须是非阻塞的)</p><p>channel.configureBlocking(false);<br>SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</p><p>SelectionKey介绍<br>一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p><p>从Selector中选择channel(Selecting Channels via a Selector)<br>选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中.</p><p>停止选择的方法<br>wakeup()方法 和close()方法。</p><p>模板代码<br>有了模板代码我们在编写程序时，大多数时间都是在模板代码中添加相应的业务代码。</p><p>客户端与服务端简单交互实例</p><p>五  Java NIO之拥抱Path和Files<br>主要内容<br>一 文件I/O基石：Path：</p><p>创建一个Path<br>File和Path之间的转换，File和URI之间的转换<br>获取Path的相关信息<br>移除Path中的冗余项</p><p>二 拥抱Files类：</p><p>Files.exists() 检测文件路径是否存在<br>Files.createFile() 创建文件<br>Files.createDirectories()和Files.createDirectory()创建文件夹<br>Files.delete()方法 可以删除一个文件或目录<br>Files.copy()方法可以吧一个文件从一个地址复制到另一个位置<br>获取文件属性<br>遍历一个文件夹<br>Files.walkFileTree()遍历整个目录</p><p>六  NIO学习总结以及NIO新特性介绍</p><p>内存映射：</p><p>这个功能主要是为了提高大文件的读写速度而设计的。内存映射文件(memory-mappedfile)能让你创建和修改那些大到无法读入内存的文件。有了内存映射文件，你就可以认为文件已经全部读进了内存，然后把它当成一个非常大的数组来访问了。将文件的一段区域映射到内存中，比传统的文件处理速度要快很多。内存映射文件它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快了。<br>七 Java NIO AsynchronousFileChannel异步文件通<br>Java7中新增了AsynchronousFileChannel作为nio的一部分。AsynchronousFileChannel使得数据可以进行异步读写。</p><ol><li><p>什么是IO流？<br>它是一种数据的流从源头流到目的地。比如文件拷贝，输入流和输出流都包括了。输入流从文件中读取数据存储到进程(process)中，输出流从进程中读取数据然后写入到目标文件。</p></li><li><p>字节流和字符流的区别。<br>字节流在JDK1.0中就被引进了，用于操作包含ASCII字符的文件。JAVA也支持其他的字符如Unicode，为了读取包含Unicode字符的文件，JAVA语言设计者在JDK1.1中引入了字符流。ASCII作为Unicode的子集，对于英语字符的文件，可以可以使用字节流也可以使用字符流。</p></li></ol><p>3.Java中流类的超类主要由那些？<br>java.io.InputStream<br>java.io.OutputStream<br>java.io.Reader<br>java.io.Writer</p><ol start="4"><li><p>FileInputStream和FileOutputStream是什么？<br>这是在拷贝文件操作的时候，经常用到的两个类。在处理小文件的时候，它们性能表现还不错，在大文件的时候，最好使用BufferedInputStream (或 BufferedReader) 和 BufferedOutputStream (或 BufferedWriter)</p></li><li><p>字节流和字符流，你更喜欢使用拿一个？<br>个人来说，更喜欢使用字符流，因为他们更新一些。许多在字符流中存在的特性，字节流中不存在。比如使用BufferedReader而不是BufferedInputStreams或DataInputStream，使用newLine()方法来读取下一行，但是在字节流中我们需要做额外的操作。</p></li></ol><p>6.System.out.println()是什么？<br>println是PrintStream的一个方法。out是一个静态PrintStream类型的成员变量，System是一个java.lang包中的类，用于和底层的操作系统进行交互。</p><p>7.什么是Filter流？<br>Filter Stream是一种IO流主要作用是用来对存在的流增加一些额外的功能，像给目标文件增加源文件中不存在的行数，或者增加拷贝的性能。</p><ol start="8"><li>有哪些可用的Filter流？<br>在java.io包中主要由4个可用的filter Stream。两个字节filter stream，两个字符filter stream. 分别是FilterInputStream, FilterOutputStream, FilterReader and FilterWriter.这些类是抽象类，不能被实例化的。<pre><code>有些Filter流的子类:</code></pre>LineNumberInputStream 给目标文件增加行号<br>DataInputStream 有些特殊的方法如readInt(), readDouble()和readLine() 等可以读取一个 int, double和一个string一次性的,<br>BufferedInputStream 增加性能<br>PushbackInputStream 推送要求的字节到系统中</li></ol><p>9.SequenceInputStream的作用？<br>这个类的作用是将多个输入流合并成一个输入流，通过SequenceInputStream类包装后形成新的一个总的输入流。在拷贝多个文件到一个目标文件的时候是非常有用的。可用使用很少的代码实现</p><p>10.说说PrintStream和PrintWriter<br>他们两个的功能相同，但是属于不同的分类。字节流和字符流。他们都有println()方法。</p><ol start="11"><li>在文件拷贝的时候，那一种流可用提升更多的性能？<br>在字节流的时候，使用BufferedInputStream和BufferedOutputStream。<br>在字符流的时候，使用BufferedReader 和 BufferedWriter</li></ol><p>12 .说说管道流(Piped Stream)</p><p>有四种管道流， PipedInputStream, PipedOutputStream, PipedReader 和 PipedWriter.在多个线程或进程中传递数据的时候管道流非常有用。</p><p>13.说说File类<br>它不属于 IO流，也不是用于文件操作的，它主要用于知道一个文件的属性，读写权限，大小等信息。注意：Java7中文件IO发生了很大的变化，专门引入了很多新的类来取代原来的基于java.io.File的文件IO操作方式。详情阅读下面的文章：</p><p>Java NIO之拥抱Path和Files</p><ol start="14"><li>说说RandomAccessFile?<br>它在java.io包中是一个特殊的类，既不是输入流也不是输出流，它两者都可以做到。他是Object的直接子类。通常来说，一个流只有一个功能，要么读，要么写。但是RandomAccessFile既可以读文件，也可以写文件。 DataInputStream 和 DataOutStream有的方法，在RandomAccessFile中都存在。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java反射总结</title>
      <link href="/2019/12/10/java%E5%8F%8D%E5%B0%84%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/10/java%E5%8F%8D%E5%B0%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>什么是反射？<br>反射就是动态加载对象，并对对象进行剖析。在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能成为Java反射机制。<br>反射的基本操作<br>创建一个类，用于演示反射的基本操作，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package fs;</span><br><span class="line">public class Student &#123;</span><br><span class="line">private long id;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public long getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setId(long id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>获取类中的所有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">Method[] methods = clz.getMethods();</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">System.out.println(&quot;方法名：&quot; + method.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;fs.Student&quot;)：初始化指定的类</span><br><span class="line">clz.getMethods()：获取类中所有的方法(包括其继承类的方法)</span><br></pre></td></tr></table></figure><p>如果只需要获取加载类中的方法，不要父类的方法，可以使用下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = clz.getDeclaredMethods();</span><br></pre></td></tr></table></figure><br>Method是方法类，可以获取方法相关的信息，除了我们上面的方法名称，我们还可以获取其他的一些信息，比如：</p><p>方法返回类型：method.getReturnType().getName()<br>方法修饰符：Modifier.toString(method.getModifiers())<br>方法参数信息： method.getParameters()<br>方法上的注解： method.getAnnotations()<br>等等…….</p><p>操作方法<br>除了可以获取Class中方法的信息，还可以通过反射来调用方法，接下来看看怎么调用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">Student stu = (Student) clz.newInstance();</span><br><span class="line">System.out.println(stu.getName());</span><br><span class="line">Method method = clz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">method.invoke(stu, &quot;猿天地&quot;);</span><br><span class="line">System.out.println(stu.getName());</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>通过class的newInstance()方法构造一个Student对象，然后调用getName()方法，这个时候输出的是null,然后通过方法名获取到setName方法，通过invoke调用方法，传入参数，然后调用getName()方法可以看到输出的就是我们设置的值“猿天地”。<br>获取类中的所有属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">Field[] fields = clz.getFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">System.out.println(&quot;属性名：&quot; + field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>clz.getFields()只能获取public的属性，包括父类的。<br>如果需要获取自己声明的各种字段，包括public，protected，private得用clz.getDeclaredFields()<br>Field是属性类，可以获取属性相关的信息，比如：</p><p>属性类型：field.getType().getName()<br>属性修饰符：Modifier.toString(field.getModifiers())<br>属性上的注解： field.getAnnotations()<br>等等…….</p><p>操作属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">Student stu = (Student) clz.newInstance();</span><br><span class="line">Field field = clz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">System.out.println(field.get(stu));</span><br><span class="line">field.set(stu, &quot;猿天地&quot;);</span><br><span class="line">System.out.println(field.get(stu));</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>通过clz.getDeclaredField(“name”);获取name属性，调用get方法获取属性的值，第一次肯定是没有值的，然后调用set方法设置值，最后再次获取就有值了，在get之前有field.setAccessible(true);这个代码，如果不加的话就会报下面的错误信息：<br>Class fs.Test can not access a member of class fs.Student with modifiers “private”<br>setAccessible(true);以取消Java的权限控制检查，让我们在用反射时可以访问访问私有变量<br>反射的优缺点？<br>优点</p><p>反射提高了程序的灵活性和扩展性,在底层框架中用的比较多，业务层面的开发过程中尽量少用。</p><p>缺点</p><p>性能不好<br>反射是一种解释操作,用于字段和方法接入时要远慢于直接代码，下面通过2段简单的代码来比较下执行的时间就可以体现出性能的问题</p><p>直接创建对象，调用方法设置值，然后获取值，时间在300ms左右<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">Student stu = new Student();</span><br><span class="line">stu.setName(&quot;猿天地&quot;);</span><br><span class="line">System.out.println(stu.getName());</span><br><span class="line">&#125;</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br></pre></td></tr></table></figure><br>利用反射来实现上面的功能，时间在500ms左右，我是在我本机测试的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">Student stu = (Student) clz.newInstance();</span><br><span class="line">Method method = clz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">method.invoke(stu, &quot;猿天地&quot;);</span><br><span class="line">System.out.println(stu.getName());</span><br><span class="line">&#125;</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br></pre></td></tr></table></figure></p><p>程序逻辑有影响</p><p>使用反射操作会模糊化程序的内部逻辑，从代码的维护角度来讲，我们更希望在源码中看到程序的逻辑，反射相当于绕过了源码的方式,因此会带来维护难度比较大的问题。<br>反射的使用场景有哪些？</p><p>实现RPC框架<br>实现ORM框架<br>拷贝属性值（BeanUtils.copyProperties）<br>……</p><p>实现RPC框架<br>RPC是远程过程调用的简称，广泛应用在大规模分布式应用中。提到RPC框架在我脑海里第一闪现的就是Dubbo,远程过程调用的实现原理简单无非就是当客户端调用的时候通过动态代理向服务提供方发送调用的信息（Netty通信），服务提供方收到后根据客户端需要调用的方法，调用本地方法，拿到结果组装返回。这里就涉及到动态方法的调用，反射也就可以排上用场了。<br>至于Dubbo中是怎么动态调用的我就不太清楚啦，没去研究过Dubbo的源码哈，我临时看了下，找到了2个相关的类JdkProxyFactory和JavassistProxyFactory。<br>JdkProxyFactory就是用的method.invoke(proxy, arguments);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class JdkProxyFactory extends AbstractProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object doInvoke(T proxy, String methodName,</span><br><span class="line">                                      Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">                                      Object[] arguments) throws Throwable &#123;</span><br><span class="line">                Method method = proxy.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">                return method.invoke(proxy, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavassistProxyFactory是用的Javassist框架来实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JavassistProxyFactory extends AbstractProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">        // TODO Wrapper cannot handle this scenario correctly: the classname contains &apos;$&apos;</span><br><span class="line">        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&apos;$&apos;) &lt; 0 ? proxy.getClass() : type);</span><br><span class="line">        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object doInvoke(T proxy, String methodName,</span><br><span class="line">                                      Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">                                      Object[] arguments) throws Throwable &#123;</span><br><span class="line">                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现ORM框架<br>关于ORM的概念本文就不做过多的介绍了，主要给大家介绍下如何用反射实现ORM的核心功能，我们以保持操作来进行讲解，也就是定义一个与数据库表对应的实体类，写一个save方法，传入我们实体类就可以将这个对象中的属性值存储到数据库中，变成一条数据。<br>还是以上面的Student来作为与表对应的实体类，下面我们看如何实现save方法中的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void save(Object data, Class&lt;?&gt; entityClass) throws Exception &#123;</span><br><span class="line">String sql = &quot;insert into &#123;0&#125;(&#123;1&#125;) values(&#123;2&#125;)&quot;;</span><br><span class="line">String tableName = entityClass.getSimpleName();</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; fs = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; values = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Field[] fields = entityClass.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">names.add(field.getName());</span><br><span class="line">fs.add(&quot;?&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">values.add(field.get(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String fieldStr = names.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">String valueStr = fs.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">System.err.println(MessageFormat.format(sql, tableName, fieldStr, valueStr));</span><br><span class="line">values.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Student stu = new Student();</span><br><span class="line">stu.setId(1);</span><br><span class="line">stu.setName(&quot;猿天地&quot;);</span><br><span class="line">save(stu, Student.class);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行main方法，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into Student(id,name) values(?,?)</span><br></pre></td></tr></table></figure><br>当然我上面只是最简单的代码，考虑也没那么全面，为的只是让大家熟悉反射的使用方式和场景，接下来我们再配合注解做一个小小的优化，注解不熟的同学可以参考我的这篇文章：《注解面试题-请了解下》<br>优化2点，定义一个TableName注解，用于描述表的信息，上面我们是直接用的类名作为表名，实际使用中很有可能表名是stu_info这样的 ，还有就是定义一个Field用于描述字段的信息，原理同上。<br>定义TableName注解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line">/**</span><br><span class="line"> * 表名</span><br><span class="line"> * @author yinjihuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface TableName &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 表名</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">定义Field注解：</span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line">/**</span><br><span class="line"> * 字段名</span><br><span class="line"> * @author yinjihuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123; ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE &#125;)</span><br><span class="line">public @interface Field &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 字段名称</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>修改实体类，增加注解的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@TableName(&quot;stu_info&quot;)</span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">private long id;</span><br><span class="line"></span><br><span class="line">@Field(&quot;stu_name&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public long getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setId(long id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>save方法中就需要考虑到有注解的情况，修改代码，增加获取注解中值的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void save(Object data, Class&lt;?&gt; entityClass) throws Exception &#123;</span><br><span class="line">String sql = &quot;insert into &#123;0&#125;(&#123;1&#125;) values(&#123;2&#125;)&quot;;</span><br><span class="line">String tableName = entityClass.getSimpleName();</span><br><span class="line">if (entityClass.isAnnotationPresent(TableName.class)) &#123;</span><br><span class="line">tableName = entityClass.getAnnotation(TableName.class).value();</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; fs = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; values = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Field[] fields = entityClass.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">String fieldName = field.getName();</span><br><span class="line">if (field.isAnnotationPresent(fs.Field.class)) &#123;</span><br><span class="line">fieldName = field.getAnnotation(fs.Field.class).value();</span><br><span class="line">&#125;</span><br><span class="line">names.add(fieldName);</span><br><span class="line">fs.add(&quot;?&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">values.add(field.get(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String fieldStr = names.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">String valueStr = fs.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">System.err.println(MessageFormat.format(sql, tableName, fieldStr, valueStr));</span><br><span class="line">values.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通上面的修改，如果有注解的情况下以注解中的值为主，没有的话就用Class中的。<br>执行main方法，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into stu_info(id,stu_name) values(?,?)</span><br></pre></td></tr></table></figure></p><p>更完整的反射实现的ORM可以参考我的框架：<a href="https://github.com/yinjihuan/smjdbctemplate" target="_blank" rel="noopener">https://github.com/yinjihuan/smjdbctemplate</a><br>拷贝属性值（BeanUtils.copyProperties）<br>在开发过程中，我们会遇到各种bean之间的转换，比如用ORM框架查询出来的数据，对应的bean,需要转换成Dto返回给调用方，这个时候就需要进行bean的转换了，下面通过简单的伪代码来讲解下：<br>Student stu = dao.get();<br>StudentDto dto = new StudentDto();<br>dto.setName(stu.getName());<br>dto.setXXX(stu.getXXX());<br>dto.set……<br>return dto;<br>如果属性多的话，光写set方法就要写很多行，有没有优雅的方式呢？<br>这个时候我们可以用Spring中的BeanUtils.copyProperties来实现上面的需求，只需要一行代码即可，关于BeanUtils.copyProperties的详细使用不做过多讲解：<br>Student stu = dao.get();<br>StudentDto dto = new StudentDto();<br>BeanUtils.copyProperties(stu, dto);<br>这个功能就是反射的功劳了，我们可以通过源码来验证下是否是通过反射来实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private static void copyProperties(Object source, Object target, Class&lt;?&gt; editable, String... ignoreProperties)</span><br><span class="line">throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">Assert.notNull(source, &quot;Source must not be null&quot;);</span><br><span class="line">Assert.notNull(target, &quot;Target must not be null&quot;);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; actualEditable = target.getClass();</span><br><span class="line">if (editable != null) &#123;</span><br><span class="line">if (!editable.isInstance(target)) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Target class [&quot; + target.getClass().getName() +</span><br><span class="line">&quot;] not assignable to Editable class [&quot; + editable.getName() + &quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">actualEditable = editable;</span><br><span class="line">&#125;</span><br><span class="line">PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);</span><br><span class="line">List&lt;String&gt; ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null);</span><br><span class="line"></span><br><span class="line">for (PropertyDescriptor targetPd : targetPds) &#123;</span><br><span class="line">Method writeMethod = targetPd.getWriteMethod();</span><br><span class="line">if (writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) &#123;</span><br><span class="line">PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());</span><br><span class="line">if (sourcePd != null) &#123;</span><br><span class="line">Method readMethod = sourcePd.getReadMethod();</span><br><span class="line">if (readMethod != null &amp;&amp;</span><br><span class="line">ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">readMethod.setAccessible(true);</span><br><span class="line">&#125;</span><br><span class="line">Object value = readMethod.invoke(source);</span><br><span class="line">if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">writeMethod.setAccessible(true);</span><br><span class="line">&#125;</span><br><span class="line">writeMethod.invoke(target, value);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new FatalBeanException(</span><br><span class="line">&quot;Could not copy property &apos;&quot; + targetPd.getName() + &quot;&apos; from source to target&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码不做过多解释，我们看最关键的2行代码，第一行是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object value = readMethod.invoke(source);</span><br></pre></td></tr></table></figure><br>通过调用读的方法将source中的值读取出来<br>第二行关键的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeMethod.invoke(target, value);</span><br></pre></td></tr></table></figure><br>通过调用写的方法进行复制到target中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java运算符及运算符的优先级</title>
      <link href="/2019/12/10/Java%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2019/12/10/Java%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>Java语言中提供了很多运算符来操作变量，现总结以下七种：<br>1、赋值运算符<br>2、算术运算符<br>3、关系运算符<br>4、逻辑运算符<br>5、位运算符<br>6、三目运算符<br>7、instanceof运算符</p><p>一、赋值运算符<br>赋值符号 “ = “<br>语法：变量名 = 表达式；<br>可以和算术运算符结合成复合赋值运算符，例如” += “、” -= “、” <em>= “、” /= “、” %= “<br>示例：”int a = 8”、” b += 18”、” m </em>= 5”</p><p>二、算术运算符</p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>加法运算</td><td>2+3</td><td>5</td></tr><tr><td>-</td><td>减法运算</td><td>5-2</td><td>3</td></tr><tr><td>*</td><td>乘法运算</td><td>2*3</td><td>6</td></tr><tr><td>/</td><td>除法运算</td><td>8/3</td><td>2</td></tr><tr><td>%</td><td>取余运算</td><td>5%3</td><td>2</td></tr><tr><td>++</td><td>自增运算</td><td>i=2; 　j=i++</td><td>i=3; 　j=2</td></tr><tr><td>–</td><td>自减运算</td><td>i=2; 　j=i–</td><td>i=1; 　j=2</td></tr></tbody></table><p>符号 “ + “、” - “、” * “、” / “、” % “、” ++ “、” – “<br>几点注意：</p><p>1、除法运算，两个操作数是整型的，结果也会是整型的，舍弃掉小数部分；如果有一个数是浮点数，结果将自动转型为浮点型<br>2、取余运算，两个操作数是整型的，结果也会是整型的，如果有一个数是浮点数，结果将自动转型为浮点型<br>3、自增自减运算，a++ 相当于 a = a + 1, a++ 是先运用在计算，++a 先计算在运用</p><p>三、关系运算符</p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>==</td><td>等于</td><td>2==3</td><td>false</td></tr><tr><td>!=</td><td>不等于</td><td>5!=2</td><td>true</td></tr><tr><td>&lt;</td><td>小于</td><td>2&lt;3</td><td>true</td></tr><tr><td>&gt;</td><td>大于</td><td>8&gt;3</td><td>true</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>5&lt;=3</td><td>false</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>5&gt;=3</td><td>true</td></tr></tbody></table><p>几点注意：</p><p>“ = “是赋值运算，” == “是等于运算<br>“ &gt; “、” &lt; “、” &gt;= “、” &lt;= “只支持数值类型的比较，” == “、” != “支持所有数据类型的比较<br>关系表达式的运算结果是布尔值<br>四、逻辑运算符</p><table><thead><tr><th>运算符</th><th>含义</th><th>运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>逻辑与</td><td>两个操作数都是true，结果才是true；左边取值无论真假，右边都会运算</td></tr><tr><td>&#124;</td><td>逻辑或</td><td>两个操作数一个是true，结果就是true；左边取值无论真假，右边都会运算</td></tr><tr><td>^</td><td>逻辑异或</td><td>两个操作相同，结果是false；两个操作不相同，结果是true</td></tr><tr><td>!</td><td>逻辑非</td><td>操作数是true，结果是false；操作数是false，结果是true</td></tr><tr><td>&amp;&amp;</td><td>短路与</td><td>两个操作数都是true，结果才是true；左边取值是false，右边不会运算</td></tr><tr><td>&#124;&#124;</td><td>短路或</td><td>两个操作数一个是true，结果就是true；左边取值是true，右边不会运算</td></tr></tbody></table><p>几点注意：</p><p>操作数只能是布尔型，操作结果也是布尔型<br>&amp; 和 &amp;&amp; 的区别： &amp;&amp; 左边是false时，不计算右边的表达式，左假即假； &amp; 无论左边真假都会计算右边的表达式<br>五、位运算符</p><table><thead><tr><th>运算符</th><th>含义</th><th>运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td><td>两个操作数都为1，结果为1</td></tr><tr><td>&#124;</td><td>按位或</td><td>两个操作数一个为1，结果为1</td></tr><tr><td>^</td><td>按位异或</td><td>两个操作数相同为0，不同为1</td></tr><tr><td>~</td><td>按位取反</td><td>操作数为1，结果为0；操作数为0，结果为1</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>右边空位补0</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>左边空位补最高位，即符号位</td></tr><tr><td>&gt;&gt;&gt;</td><td>无称号右移</td><td>左边空位补0</td></tr></tbody></table><p>示例: a和b是两个整数，下面是按位计算的形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = 0011 1100 ;    </span><br><span class="line">b = 0000 1101 ;</span><br><span class="line"></span><br><span class="line">a &amp; b = 0000 1100 ;</span><br><span class="line">a | b = 0011 1101 ;</span><br><span class="line">a ^ b = 0011 0001 ;</span><br><span class="line">~a = 1100 0011 ;</span><br><span class="line">a&lt;&lt;2  = 1111 0000 ;</span><br><span class="line">a&gt;&gt;2  = 1111 ;</span><br><span class="line">a&gt;&gt;&gt;2 = 0000 1111 ;</span><br></pre></td></tr></table></figure><p>六、三目运算符<br>也叫三元运算符，或是条件运算符，是Java语言中唯一需要三个操作数的运算符<br>符号:　表达式1 ? 表达式2 : 表达式3<br>如果表达式1为true，则返回表达式2的值，如果表达式1为false，则返回表达式3的值<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int m,n;</span><br><span class="line">m = 5&lt;10 ? 10 : 20;  //先判断5&lt;7，为真，则m = 10</span><br><span class="line">n = 5&gt;10 ? 10 : 20;  //先判断5&lt;7，为假，则n = 20</span><br></pre></td></tr></table></figure><p>七、instanceof运算符<br>instanceof运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型），结果返回一个布尔值<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;张三&quot;;</span><br><span class="line">boolean flag = name instanceof String;  //name是String类型的，返回true</span><br></pre></td></tr></table></figure><p>运算符号的优先级<br><!-- | 优先级|运算符|结合性|| ------ | ------ | ------ | --></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">含义</th><th>运算规则</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">( )　[ ] 　.</td><td>从左到右</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">! 　~　 ++　 –</td><td>从右到左</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">&#42;　 /　 &#37;</td><td>从左到右</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">+　 -</td><td>从左到右</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">&lt;&lt; 　&gt;&gt;　 &gt;&gt;&gt;</td><td>从左到右</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">&lt; 　&lt;=　 &gt; 　&gt;=　 instanceof</td><td>从左到右</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">== 　!=</td><td>从左到右</td></tr><tr><td style="text-align:center">8</td><td style="text-align:left">&amp;</td><td>从左到右</td></tr><tr><td style="text-align:center">9</td><td style="text-align:left">^</td><td>从左到右</td></tr><tr><td style="text-align:center">10</td><td style="text-align:left">&#124;</td><td>从左到右</td></tr><tr><td style="text-align:center">11</td><td style="text-align:left">&amp;&amp;</td><td>从左到右</td></tr><tr><td style="text-align:center">12</td><td style="text-align:left">&#124;&#124;</td><td>从左到右</td></tr><tr><td style="text-align:center">13</td><td style="text-align:left">? :</td><td>从左到右</td></tr><tr><td style="text-align:center">14</td><td style="text-align:left">= 　+= 　-= 　*=　 /=　 %=　 &amp;=　 &#124;=　 ^=　 ~= 　&lt;&lt;= 　&gt;&gt;=　 &gt;&gt;&gt;=</td><td>从右到左</td></tr><tr><td style="text-align:center">15</td><td style="text-align:left">，</td><td>从右到左</td></tr></tbody></table><p>当多个运算符出现在一个表达式中，谁的优先级别高，就先执行谁。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果完全不一样。<br>有一个口诀可以帮助记忆：</p><p>单算移关与，异或逻条赋<br>括号级别最高，逗号级别最低，单目 &gt; 算术 &gt; 位移 &gt; 关系 &gt; 逻辑 &gt; 三目 &gt; 赋值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基本数据类型和引用类型</title>
      <link href="/2019/12/09/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/12/09/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>八种基本数据类型<br><img src="/images/java基本数据类型和引用类型/基本数据类型.png" alt=""></p><p>除掉这四类八种基本类型，其它的都是对象，也就是引用类型，包括数组。</p><p>来看一段示例代码：</p><p>一个Person类，提供了一个构造方法，一些get/set方法：<br><img src="/images/java基本数据类型和引用类型/v2-cfd01239a6114d8f72352e7d5b44a41f_hd.png" alt=""></p><p>下面是测试的main方法：<br><img src="/images/java基本数据类型和引用类型/v2-a020f5f1b5b248f200391512cafb7513_hd.png" alt=""></p><p>先看第一句代码</p><p><img src="/images/java基本数据类型和引用类型/v2-44bced166052b8938755d5c8d4a9de3d_hd.png" alt=""><br>方法体里声明的基本数据类型在栈内存里，我们画一下<br><img src="/images/java基本数据类型和引用类型/v2-c6981f1aa0a68443af10c3de285026ea_hd.png" alt=""></p><p>继续执行以下代码</p><p><img src="/images/java基本数据类型和引用类型/v2-002755ee9e7ed63dc4b6d42e35bf9b8f_hd.png" alt=""></p><p>对于基本数据类型来说，赋值（=号）就相当于拷贝了一份值，把int1的值100，拷贝给int2，继续画图<br><img src="/images/java基本数据类型和引用类型/v2-fe67275640ecf78439111f7514919a7a_hd.png" alt=""></p><p>int1=500，直接修改int1的值为500，表现如下图<br><img src="/images/java基本数据类型和引用类型/v2-317de060c61f27d6c4093f586fb47c8a_hd.png" alt=""></p><p>分别打印int1，int2的值，相信没有人会答错，分别是500，100。再来看数组的初始化</p><p><img src="/images/java基本数据类型和引用类型/v2-4996988f6e9ecd487b5b000a28ceed0c_hd.png" alt=""></p><p>先初始化arr1，当执行到new这个关键字，会在堆内存分配内存空间，并把该内存空间的地址赋值给arr1。<br><img src="/images/java基本数据类型和引用类型/v2-2be66d9d5e691906a89fedd36a7b6c94_hd.png" alt=""></p><p>继续执行以下代码<br><img src="/images/java基本数据类型和引用类型/v2-76163c63cf6ba26ee9ecdf6aaf9e43d3_hd.png" alt=""></p><p>这儿arr2初始化时并没有new关键字，并不会在堆内存里新开辟一块空间，而是把arr1里存的堆内存地址直接赋值给了arr2，对于引用类型来说，赋值（=号）就相当于拷贝了一份内存地址，也就是说arr1，arr2现在指向了同一块堆内存，表现形势如下图<br><img src="/images/java基本数据类型和引用类型/v2-eec4ae0d9e4f0368632f83cdb84390ad_hd.png" alt=""></p><p>这时候执行如下代码<br><img src="/images/java基本数据类型和引用类型/v2-977c39560d6ff1b71196db80b5ff3023_hd.png" alt=""></p><p>虽然只是修改arr1数组下标位置为3的值<br><img src="/images/java基本数据类型和引用类型/v2-0b745eae4cec0d8544a3ed4ac38dbef6_hd.png" alt=""></p><p> 但由于<br> 数组arr1和数组arr2指向同一块堆内存，<br> 打印arr1[3]和arr2[3]的值，都是<br> 8。<br> 你答对了吗？再来看对象的初始化<br><img src="/images/java基本数据类型和引用类型/v2-2c5c3e2d89054e2a4996ed800739f357_hd.png" alt=""></p><p>当看到这个new，这货肯定在堆内存里开辟了一块内存空间，Person里有一个叫name的String对象，String这个对象有点特殊，虽然没有new这个关键字，但还是在堆内存中开辟了一块空间，在String是一个很普通的类一文中已经讲解过了，这里就不再细讲了，String底层是数组实现的，数组也是引用类型，age为基本数据类型，表现如下图<br><img src="/images/java基本数据类型和引用类型/v2-84aed37c59f46cd56a46bd6c54623cd3_hd.png" alt=""></p><p>上图中大框里的内容就是整个Person对象在堆内存中的体现，继续执行以下代码<br><img src="/images/java基本数据类型和引用类型/v2-24fb5472676485bc1d96a72f8f02ab9c_hd.png" alt=""></p><p>没有new关键字，per2不会在堆内存中新开辟空间，和数组一样，也是把per1的内存地址直接赋值给了per2<br><img src="/images/java基本数据类型和引用类型/v2-65a1a85bf445923e68edc51fcc950ac2_hd.png" alt=""></p><p>当我们修改per1的属性的时候<br><img src="/images/java基本数据类型和引用类型/v2-dcc8e0743cda50d7e19d05621039902b_hd.png" alt=""></p><p>如下图两个红框里的内容，给对象（数组也是对象）赋值其实就是相当于引用重新指向一块堆内存，基本数据类型是直接修改值，表现如下图<br><img src="/images/java基本数据类型和引用类型/v2-ff22a589b60f01fc3c54f771fb919a20_hd.png" alt=""></p><p>所以，不管打印per1还是per2的name、age，打印出来的结果都是<br>“李四”、35<br>，这个你也答对了吗？最后，我们来验证一下，结果是不是和文中说的一致。<br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""></p><p>结果完全一致，回过头来看看<br>Java里的“==”比较符，<br>结果就不难理解了，代码如下<br><img src="/images/java基本数据类型和引用类型/v2-01779bec27a57527d24750289eccf4dc_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""><br><img src="/images/java基本数据类型和引用类型/v2-554baf09fbb03374a26c8f9b722ba0fb_hd.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java面试题及答案汇总-命名规则</title>
      <link href="/2019/12/09/java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
      <url>/2019/12/09/java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<pre><code>java程序是由类组成的；java应用程序必须有一个包含main方法的public类，main方法是程序的入口；java源文件的命名规则：如果有public类，那么源文件名就是public类名(一个文件中只能有一个public类)，而类名命名规则是：类的名字必须由大写字母开头而单词中的其他字母均为小写；如果类名称由多个单词组成，则每个单词的首字母均应为大写，如果类名称中包含单词缩写，则这个所写词的每个字母均应大写，命名类时应尽量选择名词。如果没有public类，就和遵循文件名命名规则；1.一个.java文件只能有1个public class(暗示可以没有)2.如果有public class,那么文件名必须与修饰符为public的类名相同(暗示,没有的话文件名可以随便起)其他：定义规范的目的是为了使项目的代码样式统一，使程序有良好的可读性。包的命名（全部小写，由域名定义）Java包的名字都是由小写单词组成。但是由于Java面向对象编程的特性，每一名Java程序员都 可以编写属于自己的Java包，为了保障每个Java包命名的唯一性，在最新的Java编程规范中，要求程序员在自己定义的包的名称之前加上唯一的前缀。 由于互联网上的域名称是不会重复的，所以程序员一般采用自己在互联网上的域名称作为自己程序包的唯一前缀。例如：net.frontfree.javagroup类的命名（单词首字母大写）根据约定，Java类名通常以大写字母开头，如果类名称由多个单词组成，则每个单词的首字母均应为大 写例如TestPage；如果类名称中包含单词缩写，则这个所写词的每个字母均应大写，如：XMLExample,还有一点命名技巧就是由于类是设计用来 代表对象的，所以在命名类时应尽量选择名词。例如： Graphics方法的命名（首字母小写，字母开头大写）方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头。例如：drawImage常量的命名（全部大写 ，常加下划线）常量的名字应该都使用大写字母，并且指出该常量完整含义。如果一个常量名称由多个单词组成，则应该用下划线来分割这些单词。例如：MAX_VALUE参数的命名参数的命名规范和方法的命名规范相同，而且为了避免阅读程序时造成迷惑，请在尽量保证参数名称为一个单词的情况下使参数的命名尽可能明确。Javadoc注释Java除了可以采用我们常见的注释方式之外，Java语言规范还定义了一种特殊的注释，也就是我们 所说的Javadoc注释，它是用来记录我们代码中的API的。Javadoc注释是一种多行注释，以/**开头，而以*/结束，注释可以包含一些 HTML标记符和专门的关键词。使用Javadoc 注释的好处是编写的注释可以被自动转为在线文档，省去了单独编写程序文档的麻烦。例如：/*** This is an example of* Javadoc* @author darchon* @version 0.1, 10/11/2002*/在每个程序的最开始部分，一般都用Javadoc注释对程序的总体描述以及版权信息，之后在主程序中 可以为每个类、接口、方法、字段添加 Javadoc注释，每个注释的开头部分先用一句话概括该类、接口、方法、字段所完成的功能，这句话应单独占据一行以突出其概括作用，在这句话后面可以跟 随更加详细的描述段落。在描述性段落之后还可以跟随一些以Javadoc注释标签开头的特殊段落，例如上面例子中的@auther和@version，这 些段落将在生成文档中以特定方式显示。变量和常量命名变量的命名主要的的命名规范有以下三种：Camel 标记法:首字母是小写的,接下来的单词都以大写字母开头Pascal 标记法:首字母是大写的,接下来的单词都以大写字母开头匈牙利标记法:在以Pascal标记法的变量前附加小写序列说明该变量的类型在Java我们一般使用匈牙利标记法，基本结构为scope_typeVariableName，它 使用1-3字符前缀来表示数据类型，3个字符的前缀必须小写，前缀后面是由表意性强的一个单词或多个单词组成的名字，而且每个单词的首写字母大写，其它字 母小写，这样保证了对变量名能够进行正确的断句。例如，定义一个整形变量，用来记录文档数量：intDocCount，其中int表明数据类型，后面为表 意的英文名，每个单词首字母大写。这样，在一个变量名就可以反映出变量类型和变量所存储的值的意义两方面内容，这使得代码语句可读性强、更加容易理解。 byte、int、char、long、float、 double、boolean和short。数据类型/前缀(附)byte bchar cshort shint ilong lchar cstring sfloat fdouble dhashtable h[] arrList lstVector vStringBuffer sbBoolean bByte btMap mapObject ob对于在多个函数内都要使用的全局变量，在前面再增加“g_”。例如一个全局的字符串变量：g_strUserInfo。在变量命名时要注意以下几点：· 选择有意义的名字，注意每个单词首字母要大写。· 在一段函数中不使用同一个变量表示前后意义不同的两个数值。· i、j、k等只作为小型循环的循环索引变量。· 避免用Flag来命名状态变量。· 用Is来命名逻辑变量，如：blnFileIsFound。通过这种给布尔变量肯定形式的命名方式，使得其它开发人员能够更为清楚的理解布尔变量所代表的意义。· 如果需要的话，在变量最后附加计算限定词，如：curSalesSum。· 命名不相包含，curSales和curSalesSum。· static final 变量(常量)的名字应该都大写，并且指出完整含义。· 如果需要对变量名进行缩写时，一定要注意整个代码中缩写规则的一致性。例如，如果在代码的某些区域中使用intCnt，而在另一些区域中又使用intCount，就会给代码增加不必要的复杂性。建议变量名中尽量不要出现缩写。· 通过在结尾处放置一个量词，就可创建更加统一的变量，它们更容易理解，也更容易搜索。例如，请使用 strCustomerFirst和strCustomerLast，而不要使用strFirstCustomer和strLastCustomer。常 用的量词后缀有：First（一组变量中的第一个）、Last（一组变量中的最后一个）、Next（一组变量中的下一个变量）、Prev（一组变量中的上 一个）、Cur（一组变量中的当前变量）。· 为每个变量选择最佳的数据类型，这样即能减少对内存的需求量，加快代码的执行速度，又会降低出错的可能性。用于变量的数据类型可能会影响该变量进行计算所产生的结果。在这种情况下，编译器不会产生运行期错误，它只是迫使该值符合数据类型的要求。这类问题极难查找。· 尽量缩小变量的作用域。如果变量的作用域大于它应有的范围，变量可继续存在，并且在不再需要该变量后的很长时间内仍然占用资源。它们的主要问题是，任何类 中的任何方法都能对它们进行修改，并且很难跟踪究竟是何处进行修改的。占用资源是作用域涉及的一个重要问题。对变量来说，尽量缩小作用域将会对应用程序的 可靠性产生巨大的影响。关于常量的命名方法，在JAVA代码中，无论什么时候，均提倡应用常量取代数字、固定字符串。也就是 说，程序中除0，1以外，尽量不应该出现其他数字。常量可以集中在程序开始部分定义或者更宽的作用域内，名字应该都使用大写字母，并且指出该常量完整含 义。如果一个常量名称由多个单词组成，则应该用下划线“_”来分割这些单词如：NUM_DAYS_IN_WEEK、MAX_VALUE。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>center os 部署 swoole</title>
      <link href="/2019/11/18/center%20os%20%E9%83%A8%E7%BD%B2%20swoole%20/"/>
      <url>/2019/11/18/center%20os%20%E9%83%A8%E7%BD%B2%20swoole%20/</url>
      
        <content type="html"><![CDATA[<p>今天通过pecl安装 swoole<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pecl install swoole</span><br></pre></td></tr></table></figure></p><p>步骤很简单，但是最后安装成功后发现phpinfo()中未显示swoole扩展，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -m | grep swoole</span><br></pre></td></tr></table></figure><p>发现报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP Warning: PHP Startup: Unable to load dynamic library &apos;/usr/lib64/php/modules/swoole.so&apos; - /usr/lib64/php/modules/swoole.so: undefined symbol: mysqlnd_find_charset_nr in Unknown on line 0</span><br></pre></td></tr></table></figure><br>        仔细看报错发现这条报错是由swoole.so报出来的，说明在加载swoole.so的时候报的找不到 mysqlnd_find_charset_nr ，这是一个以 mysqlnd 打头的一个关键字，而 mysqlnd 又是 PHP 的一个扩展，通过阅读 swoole/swoole.mysql.c 的源码我们发现有如下一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const MYSQLND_CHARSET* cset = mysqlnd_find_charset_nr(client-&gt;connector.character_set);</span><br><span class="line"> </span><br><span class="line">if (cset == NULL)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    swoole_php_fatal_error(E_ERROR, &quot;unknown mysql charset[%s].&quot;, client-&gt;connector.character_set);</span><br><span class="line"> </span><br><span class="line">    RETURN_FALSE;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码我们可以看出，原来 swoole 是需要依赖 msyqlnd 这个扩展的，我们发现 phpinfo() 里面 msyqlnd 扩展是存在的为什么还会报这个错呢。</p><p>　　最后发现 PHP默认加载的扩展都在 /usr/lib64/php/modules/ 这个目录里在，这里面的 .so 文件是默认加载的，关于这些扩展的配置不是在 /etc/php.ini 中，而是在 /etc/php.d/ 这个目录中，这个目录当中的所有的 .ini 文件是在 /etc/php.ini 加载完成后再加载的，而我们的 extension=swoole.so 的配置是写在 /etc/php.ini 的文件末尾，所以是先加载了 swoole.so 然后再加载 mysqlnd.so，这就导致了 swoole 找不到 mysqlnd_find_charset_nr 。</p><p>解决方法：<br>1、将/etc/php.d/ 目录中的mysqlnd.ini文件删除</p><p>2、在 /etc/php.ini 的 extension=swoole.so 上面一行添加 extension=mysqlnd.so</p><p>3、重新启动 php-fpm </p><p>这样可以解决问题了，同样可能还会遇到以下报错：</p><p>PHP Warning: PHP Startup: Unable to load dynamic library ‘/usr/lib64/php/modules/swoole.so’ - /usr/lib64/php/modules/swoole.so: undefined symbol: php_sockets_le_socket in Unknown on line 0</p><p>解决的方法也是类似的：</p><p>1、将/etc/php.d/ 目录中的sockets.ini文件删除</p><p>2、在 /etc/php.ini 的 extension=swoole.so 上面一行添加 extension=sockets.so</p><p>3、重新启动 php-fpm </p><p>问题解决，安装swoole过程中，如果有其它报错，也可以参考Github上关于swoole的issue，附上链接：</p><p>Swoole安装问题，及websocket示例问题总结</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java、tomcat安装与部署</title>
      <link href="/2019/11/18/java%E3%80%81tomcat%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/11/18/java%E3%80%81tomcat%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>java安装<br>一、下载jdk</p><p>jdk下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>下载jdk-8u152-linux-x64.rpm 或 jdk-8u152-linux-x64.tar.gz(根据自己的系统位数选择对应的包)</p><p>如图：</p><p>二、安装jdk</p><p>因为我安装的CentOS7.4系统自带jdk1.8，所以为了演示如何安装jdk，我需要先卸载系统自带的jdk</p><p>查看当前系统jdk的版本：java -version</p><p>列举匹配已安装的java的软件包：yum list installed | grep java</p><p>卸载安装的jdk：(yum命令参考：<a href="http://man.linuxde.net/yum" target="_blank" rel="noopener">http://man.linuxde.net/yum</a>)</p><p>yum -y remove java-1.7.0-openjdk*  </p><p>yum -y remove java-1.8.0-openjdk*</p><p>当结果出现了完毕！，就表示卸载成功。</p><p>安装jdk(介绍三种方法)</p><p>方法一：利用yum源来安装jdk（此方法不需要配置环境变量）</p><p>查看yum库中的java安装包 ：yum -y list java*</p><p>安装需要的jdk版本的所有java程序：yum -y install java-1.8.0-openjdk*</p><p>(安装完之后，默认的安装目录是在: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64)</p><p>当结果出现了完毕！即安装完成。</p><p>查看java版本：java -version</p><p>方法二：用rpm安装jdk(可以使用man rpm命令查看rpm的帮助文档)</p><p>使用Xftp将下载好的jdk-8u152-linux-x64.rpm上传到CentOs上去，我这里放到了/home/lisonglin下 </p><p>使用rpm命令安装： rpm -ivh jdk-8u152-linux-x64.rpm</p><p>(默认安装在/usr/java目录下，不用配置环境变量)</p><p>方法三：手动解压JDK的压缩包，然后设置环境变量</p><p>使用Xftp将下载好的jdk-8u152-linux-x64.tar.gz上传到CentOs上去，我这里放到了/home/lisonglin下</p><p>先将之前使用rpm方式安装的jdk卸载掉(如果没有安装过可跳过此步骤)</p><p>查询之前安装的jdk名称：rpm -qa | grep jdk</p><p>卸载jdk：rpm -e –nodeps jdk1.8    (此处也可以使用全名jdk1.8-1.8.0_152-fcs.x86_64)</p><p>卸载完成！</p><p>1、复制安装包到/usr/java目录中(目录可以自己选)：cp jdk-8u152-linux-x64.tar.gz  /usr/java</p><p>2、切换到/usr/java目录下：cd /usr/java</p><p>3、解压缩包：tar -zxvf jdk-8u152-linux-x64.tar.gz </p><p>解压成功（表式JDK已安装成功，可查看jdk的文件夹）</p><p>此时java -version命令还不能使用：</p><p>4、配置环境变量</p><p>使用vim /etc/profile 编辑profile文件 输入： vim /etc/profile</p><p>向文件里面追加以下内容：</p><p>#set java environment<br>JAVA_HOME=/usr/java/jdk1.8.0_152<br>JRE_HOME=$JAVA_HOME/jre<br>PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin<br>CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib<br>export JAVA_HOME JRE_HOME PATH CLASSPATH</p><p>注释：</p><p>JAVA_HOME指明JDK安装路径，就是刚才安装时所选择的路径，此路径下包括lib，bin，jre等文件夹（tomcat，Eclipse的运行都需要依靠此变量）。</p><p>CLASSPATH为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别，设：.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib。CLASSPATH变量值中的.表示当前目录</p><p>PATH使得系统可以在任何路径下识别java命令，设为：$JAVA_HOME/bin:$JRE_HOME/bin。</p><p>特别注意：环境变量值的结尾没有任何符号，不同值之间用:隔开（windows中用;）。</p><p>5、使配置文件生效：source /etc/profile</p><p>6、测试配置是否成功</p><p>tomcat</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>php7打开页面为空白</title>
      <link href="/2019/06/27/php7%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%E4%B8%BA%E7%A9%BA%E7%99%BD/"/>
      <url>/2019/06/27/php7%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%E4%B8%BA%E7%A9%BA%E7%99%BD/</url>
      
        <content type="html"><![CDATA[<p>由于nginx与php-fpm之间的一个小bug，会导致这样的现象： 网站中的静态页面 <em>.html 都能正常访问，而 </em>.php 文件虽然会返回200状态码， 但实际输出给浏览器的页面内容却是空白。 简而言之，原因是nginx无法正确的将 *.php 文件的地址传递给php-fpm去解析， 相当于php-fpm接受到了请求，但这请求却指向一个不存在的文件，于是返回空结果。 为了解决这个问题，需要改动nginx默认的fastcgiparams配置文件： vi /etc/nginx/fastcgi_params 在文件的最后增加两行： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">fastcgi_param PATH_INFO                $fastcgi_script_name;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> php </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ssh登录</title>
      <link href="/2019/06/17/ssh/"/>
      <url>/2019/06/17/ssh/</url>
      
        <content type="html"><![CDATA[<p>秘钥登录</p><ol><li>打开 SSH 客户端（ Mac 自带终端）。</li><li>输入 ssh <a href="mailto:root@x.x.x.x" target="_blank" rel="noopener">root@x.x.x.x</a> 或者输入 ssh -q -l root -p 22 x.x.x.x</li><li>输入密码。</li></ol><p>证书登录</p><ol><li>打开 SSH 客户端（ Mac 自带终端）。</li><li>查找您云服务器关联的 SSH 密钥文件本地存放地址。</li><li><p>密钥必须不公开可见，SSH 才能工作。<br> chmod 400 documents/summary/tencentcloud/tencent_cloud_ssh.dms</p></li><li><p>输入命令：ssh [-i 密钥文件路径] <a href="mailto:root@x.x.x.x" target="_blank" rel="noopener">root@x.x.x.x</a>。<br> ssh -i “documents/summary/tencentcloud/tencent_cloud_ssh.dms” <a href="mailto:root@x.x.x.x" target="_blank" rel="noopener">root@x.x.x.x</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>php混淆文件</title>
      <link href="/2019/06/13/php%E6%B7%B7%E6%B7%86/"/>
      <url>/2019/06/13/php%E6%B7%B7%E6%B7%86/</url>
      
        <content type="html"><![CDATA[<p>使用方式：</p><p>修改 filename 为文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line"> </span><br><span class="line"> function RandAbc($length = &quot;&quot;) &#123; // 返回随机字符串  </span><br><span class="line">     $str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;  </span><br><span class="line">     return str_shuffle($str);  </span><br><span class="line"> &#125;   </span><br><span class="line"> </span><br><span class="line"> $filename = &apos;Api.php&apos;; //要加密的文件  </span><br><span class="line"> $T_k1 = RandAbc(); //随机密匙1  </span><br><span class="line"> $T_k2 = RandAbc(); //随机密匙2  </span><br><span class="line"> $vstr = file_get_contents($filename);  </span><br><span class="line"> $v1 = base64_encode($vstr);  </span><br><span class="line"> $c = strtr($v1, $T_k1, $T_k2); //根据密匙替换对应字符。  </span><br><span class="line"> $c = $T_k1.$T_k2.$c;  </span><br><span class="line"> $q1 = &quot;O00O0O&quot;;  </span><br><span class="line"> $q2 = &quot;O0O000&quot;;  </span><br><span class="line"> $q3 = &quot;O0OO00&quot;;  </span><br><span class="line"> $q4 = &quot;OO0O00&quot;;  </span><br><span class="line"> $q5 = &quot;OO0000&quot;;  </span><br><span class="line"> $q6 = &quot;O00OO0&quot;;  </span><br><span class="line"> $s = &apos;$&apos;.$q6.&apos;=urldecode(&quot;%6E1%7A%62%2F%6D%615%5C%76%740%6928%2D%70%78%75%71%79%2A6%6C%72%6B%64%679%5F%65%68%63%73%77%6F4%2B%6637%6A&quot;);$&apos;.$q1.&apos;=$&apos;.$q6.&apos;&#123;3&#125;.$&apos;.$q6.&apos;&#123;6&#125;.$&apos;.$q6.&apos;&#123;33&#125;.$&apos;.$q6.&apos;&#123;30&#125;;$&apos;.$q3.&apos;=$&apos;.$q6.&apos;&#123;33&#125;.$&apos;.$q6.&apos;&#123;10&#125;.$&apos;.$q6.&apos;&#123;24&#125;.$&apos;.$q6.&apos;&#123;10&#125;.$&apos;.$q6.&apos;&#123;24&#125;;$&apos;.$q4.&apos;=$&apos;.$q3.&apos;&#123;0&#125;.$&apos;.$q6.&apos;&#123;18&#125;.$&apos;.$q6.&apos;&#123;3&#125;.$&apos;.$q3.&apos;&#123;0&#125;.$&apos;.$q3.&apos;&#123;1&#125;.$&apos;.$q6.&apos;&#123;24&#125;;$&apos;.$q5.&apos;=$&apos;.$q6.&apos;&#123;7&#125;.$&apos;.$q6.&apos;&#123;13&#125;;$&apos;.$q1.&apos;.=$&apos;.$q6.&apos;&#123;22&#125;.$&apos;.$q6.&apos;&#123;36&#125;.$&apos;.$q6.&apos;&#123;29&#125;.$&apos;.$q6.&apos;&#123;26&#125;.$&apos;.$q6.&apos;&#123;30&#125;.$&apos;.$q6.&apos;&#123;32&#125;.$&apos;.$q6.&apos;&#123;35&#125;.$&apos;.$q6.&apos;&#123;26&#125;.$&apos;.$q6.&apos;&#123;30&#125;;eval($&apos;.$q1.&apos;(&quot;&apos;.base64_encode(&apos;$&apos;.$q2.&apos;=&quot;&apos;.$c.&apos;&quot;;eval(\&apos;?&gt;\&apos;.$&apos;.$q1.&apos;($&apos;.$q3.&apos;($&apos;.$q4.&apos;($&apos;.$q2.&apos;,$&apos;.$q5.&apos;*2),$&apos;.$q4.&apos;($&apos;.$q2.&apos;,$&apos;.$q5.&apos;,$&apos;.$q5.&apos;),$&apos;.$q4.&apos;($&apos;.$q2.&apos;,0,$&apos;.$q5.&apos;))));&apos;).&apos;&quot;));&apos;;  </span><br><span class="line"> </span><br><span class="line"> $s = &apos;&lt;?php &apos;.&quot;\n&quot;.$s.&quot;\n&quot;.&apos; ?&gt;&apos;;  </span><br><span class="line"> //echo $s;  </span><br><span class="line"> // 生成 加密后的PHP文件  </span><br><span class="line"> $fpp1 = fopen(&apos;temp_&apos;.$filename, &apos;w&apos;);  </span><br><span class="line"> fwrite($fpp1, $s) or die(&apos;写文件错误&apos;);  </span><br><span class="line"> </span><br><span class="line"> ?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android选择打包类型(release、debug)</title>
      <link href="/2019/06/04/android%E9%80%89%E6%8B%A9%E6%89%93%E5%8C%85%E7%B1%BB%E5%9E%8B(release%E3%80%81debug)/"/>
      <url>/2019/06/04/android%E9%80%89%E6%8B%A9%E6%89%93%E5%8C%85%E7%B1%BB%E5%9E%8B(release%E3%80%81debug)/</url>
      
        <content type="html"><![CDATA[<ol><li>在Android Studio 顶部栏中有Build 下拉菜单中有 select Build Variants… </li><li>在Build Variants 中model 选择需要输出的arr 包类型，debug 或者 release 类型</li><li>在Android Studio 顶部栏中有Build 下拉菜单中有 Rebuild Project</li><li>在Model 的build/outputs/arr/ 输出arr 文件</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>linux配置开机脚本、以其他用户身份运行</title>
      <link href="/2019/04/26/linux%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/04/26/linux%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>1.开机脚本</p><p>linux开机的时候会自动执行 /etc/rc.local 里面的命令<br>将命令写在 exit 0 之前便可执行</p><p>2.以其他用户身份运行</p><p>以其他身份用户运行并修改可以避免操作修改了文件所有者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - ubuntu -c &apos;cd COMMAND&apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>php7安装redis扩展</title>
      <link href="/2019/04/12/php7%E5%AE%89%E8%A3%85redis%E6%89%A9%E5%B1%95/"/>
      <url>/2019/04/12/php7%E5%AE%89%E8%A3%85redis%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br><span class="line">apt-get install php7.0-dev        # 为了有phpize命令</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/phpredis/phpredis.git # 下载redi包，需要翻墙才能下载</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd phpredis</span><br><span class="line">git checkout php7</span><br><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cd ..</span><br><span class="line">rm -rf phpredis</span><br></pre></td></tr></table></figure><p>最后将 extension=redis.so 写入php.ini文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用gitlab CI/CD 完成自动部署</title>
      <link href="/2019/02/15/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/02/15/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>添加Gitlab的官方源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># For Debian/Ubuntu</span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bash</span><br><span class="line"></span><br><span class="line"># For CentOS</span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure></p><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># For Debian/Ubuntu</span><br><span class="line">sudo apt-get install gitlab-ci-multi-runner</span><br><span class="line"></span><br><span class="line"># For CentOS</span><br><span class="line">sudo yum install gitlab-ci-multi-runner</span><br></pre></td></tr></table></figure></p><p>注册Runner<br>Runner需要注册到Gitlab才可以被项目所使用，一个gitlab-ci-multi-runner服务可以注册多个Runner。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gitlab-ci-multi-runner register</span><br><span class="line"></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line">https://mygitlab.com/ci</span><br><span class="line">Please enter the gitlab-ci token for this runner</span><br><span class="line">xxx-xxx-xxx</span><br><span class="line">Please enter the gitlab-ci description for this runner</span><br><span class="line">my-runner</span><br><span class="line">INFO[0034] fcf5c619 Registering runner... succeeded</span><br><span class="line">Please enter the executor: shell, docker, docker-ssh, ssh?</span><br><span class="line">docker</span><br><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">node:4.5.0</span><br><span class="line">INFO[0037] Runner registered successfully. Feel free to start it, but if it&apos;s</span><br><span class="line">running already the config should be automatically reloaded!</span><br></pre></td></tr></table></figure></p><p>更新Runner<br>如果需要更新Runner，只需要执行以下脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># For Debian/Ubuntu</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gitlab-ci-multi-runner</span><br><span class="line"></span><br><span class="line"># For CentOS</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install gitlab-ci-multi-runner</span><br></pre></td></tr></table></figure><br>  Runner高级配置<br>通过gitlab-ci-multi-runner register注册的Runner配置会存储在/etc/gitlab-runner/config.toml中，如果需要修改可直接编辑该文件。详见这里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">concurrent = 4</span><br><span class="line">check_interval = 0</span><br><span class="line"></span><br><span class="line">[[runners]]</span><br><span class="line">  name = &quot;test&quot;</span><br><span class="line">  url = &quot;http://your-domain.com/ci&quot;</span><br><span class="line">  token = &quot;your-token&quot;</span><br><span class="line">  executor = &quot;docker&quot;</span><br><span class="line">  [runners.docker]</span><br><span class="line">    tls_verify = false</span><br><span class="line">    image = &quot;node:4.5.0&quot;</span><br><span class="line">    privileged = false</span><br><span class="line">    disable_cache = false</span><br><span class="line">    volumes = [&quot;/cache&quot;]</span><br><span class="line">  [runners.cache]</span><br><span class="line">  [runners.kubernetes]</span><br><span class="line">    host = &quot;&quot;</span><br><span class="line">    cert_file = &quot;&quot;</span><br><span class="line">    key_file = &quot;&quot;</span><br><span class="line">    ca_file = &quot;&quot;</span><br><span class="line">    image = &quot;&quot;</span><br><span class="line">    namespace = &quot;&quot;</span><br><span class="line">    privileged = false</span><br><span class="line">    cpus = &quot;&quot;</span><br><span class="line">    memory = &quot;&quot;</span><br><span class="line">    service_cpus = &quot;&quot;</span><br><span class="line">    service_memory = &quot;&quot;</span><br></pre></td></tr></table></figure><br>到这里我们的Runner就安装配置好了，接下来是对项目根目录中.gitlab-ci.yml进行配置。</p><p>配置构建任务<br>在项目根目录添加.gitlab-ci.yml文件<br>关于该文件的各项配置请见</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 这里使用了我自己的docker image，配置了自己需要的环境</span><br><span class="line">image: wuyanxin/node</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">MYSQL_DATABASE: wan_ark-unit</span><br><span class="line">MYSQL_ALLOW_EMPTY_PASSWORD: &quot;yes&quot;</span><br><span class="line"></span><br><span class="line"># 关于service请见: http://docs.gitlab.com/ce/ci/docker/using_docker_images.html#what-is-service</span><br><span class="line">services:</span><br><span class="line">- mysql:5.6</span><br><span class="line">- redis:3.2.4</span><br><span class="line"></span><br><span class="line">stages:</span><br><span class="line">- test</span><br><span class="line">- eslint</span><br><span class="line">- deploy</span><br><span class="line"></span><br><span class="line">before_script:</span><br><span class="line">- echo &apos;REDIS_HOST=redis&apos; &gt;&gt; .env</span><br><span class="line">- echo &apos;DB_HOST=mysql&apos; &gt;&gt; .env</span><br><span class="line">- yarn install</span><br><span class="line"></span><br><span class="line">test_service:</span><br><span class="line">stage: test</span><br><span class="line">script:</span><br><span class="line">- npm run build</span><br><span class="line">- npm test</span><br><span class="line"></span><br><span class="line">eslint_src: </span><br><span class="line">stage: eslint</span><br><span class="line">script:</span><br><span class="line">- npm run lint</span><br><span class="line">allow_failure: true</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">stage: deploy</span><br><span class="line">script:</span><br><span class="line">- echo &apos;deployd!&apos;</span><br><span class="line">only: </span><br><span class="line">- master</span><br></pre></td></tr></table></figure><br>这里使用了nodejs项目作为例子，其他语言类似语法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue引用element-ui与webpack</title>
      <link href="/2019/02/12/vue%E5%BC%95%E7%94%A8element-ui/"/>
      <url>/2019/02/12/vue%E5%BC%95%E7%94%A8element-ui/</url>
      
        <content type="html"><![CDATA[<p>从新建vue项目到引入组件Element<br>一、新建项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.查看 node和npm是不是已经安装好命令：node -v  npm -v (没有安装的先安装环境);</span><br><span class="line">2.npm install -g cnpm --registry=https://registry.npm.taobao.org  (安装国内的淘宝镜像文件，后面的安装npm可以全部改为cnpm)</span><br><span class="line">3.安装 vue-cli   </span><br><span class="line">1、cnpm install -g vue</span><br><span class="line">2、cnpm install -g vue-cli </span><br><span class="line">4. 安装 webpack   cnpm install -g webpack </span><br><span class="line">5.cd  你的运行目录</span><br><span class="line">6.新建vue项目      vue init webpack vuedemo</span><br><span class="line">7.进入项目目录     cd vuedemo</span><br><span class="line">8.安装依赖        cnpm install</span><br><span class="line">9.运行项目        cnpm run dev</span><br><span class="line">10.发布项目       cnpm run build</span><br><span class="line">注：mac电脑需要在安装淘宝镜像前执行： sudo chown -R $USER /usr/local</span><br></pre></td></tr></table></figure><br>二、使用element-ui前需安装修改的配置：</p><ol><li>安装 loader 模块：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnpm install style-loader -D</span><br><span class="line">cnpm install css-loader -D</span><br><span class="line">cnpm install file-loader -D</span><br></pre></td></tr></table></figure></li><li>安装 Element-UI 模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install element-ui --save </span><br></pre></td></tr></table></figure>三、引入Element，前面已经全局安装了element-ui，只需要在Vue项目中引入即可<br>打开项目：src/main.js,添加下面三条<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from &apos;element-ui&apos;</span><br><span class="line">import &apos;element-ui/lib/theme-chalk/index.css&apos;</span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure></li></ol><p>四、然后在.vue文件里就直接可以用了</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cytoscape在vue中安装实例</title>
      <link href="/2019/02/11/Cytoscape%E5%9C%A8vue%E4%B8%AD%E5%AE%89%E8%A3%85%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/02/11/Cytoscape%E5%9C%A8vue%E4%B8%AD%E5%AE%89%E8%A3%85%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>首先创建vue项目，并在项目下安装Cytoscape包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue create test #创建vue项目</span><br><span class="line">cd test</span><br><span class="line">npm i cytoscape --save #加载cytoscape模块</span><br></pre></td></tr></table></figure><br>创建index.vue文件并且写入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;cy&quot; style=&quot;width: 100%;height: 100%;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var cytoscape = require(&quot;cytoscape&quot;);</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Cytoscape&quot;,</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  created: function() &#123;&#125;,</span><br><span class="line">  data: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      input: &quot;&quot;,</span><br><span class="line">      output: &quot;&quot;,</span><br><span class="line">      msg: &quot;vue to cytoscape&quot;,</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add_node: function() &#123;</span><br><span class="line">      console.info(this.cy);</span><br><span class="line">      this.cy.add([</span><br><span class="line">        &#123;</span><br><span class="line">          group: &quot;nodes&quot;,</span><br><span class="line">          data: &#123; id: &quot;node&quot; + this.count &#125;,</span><br><span class="line">          position: &#123; x: 300, y: 200 &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          group: &quot;edges&quot;,</span><br><span class="line">          data: &#123;</span><br><span class="line">            id: &quot;edge&quot; + this.count,</span><br><span class="line">            source: &quot;node&quot; + this.count,</span><br><span class="line">            target: &quot;cat&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]);</span><br><span class="line">    &#125;,</span><br><span class="line">    view_init: function() &#123;</span><br><span class="line">      this.cy = cytoscape(&#123;</span><br><span class="line">        container: document.getElementById(&quot;cy&quot;),</span><br><span class="line">        boxSelectionEnabled: false,</span><br><span class="line">        autounselectify: true,</span><br><span class="line">        style: cytoscape</span><br><span class="line">          .stylesheet()</span><br><span class="line">          .selector(&quot;node&quot;)</span><br><span class="line">          .css(&#123;</span><br><span class="line">            height: 80,</span><br><span class="line">            width: 80,</span><br><span class="line">            &quot;background-fit&quot;: &quot;cover&quot;,</span><br><span class="line">            &quot;border-color&quot;: &quot;#000&quot;,</span><br><span class="line">            &quot;border-width&quot;: 3,</span><br><span class="line">            &quot;border-opacity&quot;: 0.5,</span><br><span class="line">            content: &quot;data(id)&quot;,</span><br><span class="line">            &quot;text-valign&quot;: &quot;center&quot;</span><br><span class="line">          &#125;)</span><br><span class="line">          .selector(&quot;.aa&quot;)</span><br><span class="line">          .css(&#123;</span><br><span class="line">            height: 80,</span><br><span class="line">            width: 80,</span><br><span class="line">            &quot;background-fit&quot;: &quot;cover&quot;,</span><br><span class="line">            &quot;border-color&quot;: &quot;red&quot;,</span><br><span class="line">            &quot;border-width&quot;: 3,</span><br><span class="line">            &quot;border-opacity&quot;: 0.5,</span><br><span class="line">            &quot;background-color&quot;: &quot;red&quot;,</span><br><span class="line">            content: &quot;data(id)&quot;,</span><br><span class="line">            &quot;text-valign&quot;: &quot;center&quot;,</span><br><span class="line">            &quot;line-color&quot;: &quot;red&quot;,</span><br><span class="line">          &#125;)</span><br><span class="line">          </span><br><span class="line">          .selector(&quot;edge&quot;)</span><br><span class="line">          .css(&#123;</span><br><span class="line">            width: 6,</span><br><span class="line">            &quot;target-arrow-shape&quot;: &quot;triangle&quot;,</span><br><span class="line">            &quot;line-color&quot;: &quot;#ffaaaa&quot;,</span><br><span class="line">            &quot;target-arrow-color&quot;: &quot;#ffaaaa&quot;,</span><br><span class="line">            &quot;curve-style&quot;: &quot;bezier&quot;</span><br><span class="line">          &#125;)</span><br><span class="line">          .selector(&quot;.bb&quot;)</span><br><span class="line">          .css(&#123;</span><br><span class="line">            &quot;line-color&quot;: &quot;#000&quot;,</span><br><span class="line">          &#125;),</span><br><span class="line"></span><br><span class="line">        elements: &#123;</span><br><span class="line">          nodes: [</span><br><span class="line">            &#123; data: &#123; id: &quot;cat&quot; &#125;, classes: [&quot;aa&quot;] &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;bird&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;ladybug&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;aphid&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;rose&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;grasshopper&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;plant&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; id: &quot;wheat&quot; &#125; &#125;</span><br><span class="line">          ],</span><br><span class="line">          edges: [</span><br><span class="line">            &#123; data: &#123; source: &quot;cat&quot;, target: &quot;bird&quot; &#125;, classes: [&quot;bb&quot;] &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;bird&quot;, target: &quot;ladybug&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;bird&quot;, target: &quot;grasshopper&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;grasshopper&quot;, target: &quot;plant&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;grasshopper&quot;, target: &quot;wheat&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;ladybug&quot;, target: &quot;aphid&quot; &#125; &#125;,</span><br><span class="line">            &#123; data: &#123; source: &quot;aphid&quot;, target: &quot;rose&quot; &#125; &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        layout: &#123;</span><br><span class="line">          name: &quot;breadthfirst&quot;,</span><br><span class="line">          directed: true,</span><br><span class="line">          padding: 10</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  mounted: function() &#123;</span><br><span class="line">    this.view_init();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">#cy &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 80%;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50px;</span><br><span class="line">  left: 0px;</span><br><span class="line">  text-align: left;</span><br><span class="line">&#125;</span><br><span class="line">.aa &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  /* font: 14px helvetica neue, helvetica, arial, sans-serif; */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><br>一个简单的示例就创建成功了，具体内容可以根据自己的需求来修改。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>运用wrk进行压力测试</title>
      <link href="/2019/01/09/%E8%BF%90%E7%94%A8wrk%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/01/09/%E8%BF%90%E7%94%A8wrk%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>用过了很多压测工具，却一直没找到中意的那款。最近试了wrk感觉不错，写下这份使用指南给自己备忘用，如果能帮到你，那也很好。<br><a id="more"></a><br>安装<br>wrk支持大多数类UNIX系统，不支持windows。需要操作系统支持LuaJIT和OpenSSL，不过不用担心，大多数类Unix系统都支持。安装wrk非常简单，只要从github上下载wrk源码，在项目路径下执行make命令即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg/wrk</span><br><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure><br>make之后，会在项目路径下生成可执行文件wrk，随后就可以用其进行HTTP压测了。可以把这个可执行文件拷贝到某个已在path中的路径，比如/usr/local/bin，这样就可以在任何路径直接使用wrk了。</p><p>默认情况下wrk会使用自带的LuaJIT和OpenSSL，如果你想使用系统已安装的版本，可以使用WITH_LUAJIT和WITH_OPENSSL这两个选项来指定它们的路径。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make WITH_LUAJIT=/usr WITH_OPENSSL=/usr</span><br></pre></td></tr></table></figure><br>基本使用<br>命令行敲下wrk，可以看到使用帮助<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Usage: wrk &lt;options&gt; &lt;url&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  Connections to keep open   </span><br><span class="line">    -d, --duration    &lt;T&gt;  Duration of test           </span><br><span class="line">    -t, --threads     &lt;N&gt;  Number of threads to use   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  Load Lua script file       </span><br><span class="line">    -H, --header      &lt;H&gt;  Add header to request      </span><br><span class="line">        --latency          Print latency statistics   </span><br><span class="line">        --timeout     &lt;T&gt;  Socket/request timeout     </span><br><span class="line">    -v, --version          Print version details      </span><br><span class="line">                                                      </span><br><span class="line">  Numeric arguments may include a SI unit (1k, 1M, 1G)</span><br><span class="line">  Time arguments may include a time unit (2s, 2m, 2h)</span><br></pre></td></tr></table></figure><br>简单翻成中文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  跟服务器建立并保持的TCP连接数量  </span><br><span class="line">    -d, --duration    &lt;T&gt;  压测时间           </span><br><span class="line">    -t, --threads     &lt;N&gt;  使用多少个线程进行压测   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  指定Lua脚本路径       </span><br><span class="line">    -H, --header      &lt;H&gt;  为每一个HTTP请求添加HTTP头      </span><br><span class="line">        --latency          在压测结束后，打印延迟统计信息   </span><br><span class="line">        --timeout     &lt;T&gt;  超时时间     </span><br><span class="line">    -v, --version          打印正在使用的wrk的详细版本信息</span><br><span class="line">                                                      </span><br><span class="line">  &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)</span><br><span class="line">  &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)</span><br></pre></td></tr></table></figure><br>看下版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrk -v</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">wrk 4.0.2 [epoll] Copyright (C) 2012 Will Glozer</span><br></pre></td></tr></table></figure><br>看到是4.0.2版本的wrk，使用了epoll。这意味着我们可以用少量的线程来跟被测服务创建大量连接，进行压测。</p><p>做一次简单压测，分析下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wrk -t8 -c200 -d30s --latency  &quot;http://www.bing.com&quot;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Running 30s test @ http://www.bing.com</span><br><span class="line">  8 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency    46.67ms  215.38ms   1.67s    95.59%</span><br><span class="line">    Req/Sec     7.91k     1.15k   10.26k    70.77%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    2.93ms</span><br><span class="line">     75%    3.78ms</span><br><span class="line">     90%    4.73ms</span><br><span class="line">     99%    1.35s </span><br><span class="line">  1790465 requests in 30.01s, 684.08MB read</span><br><span class="line">Requests/sec:  59658.29</span><br><span class="line">Transfer/sec:     22.79MB</span><br></pre></td></tr></table></figure><br>以上使用8个线程200个连接，对bing首页进行了30秒的压测，并要求在压测结果中输出响应延迟信息。以下对压测结果进行简单注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Running 30s test @ http://www.bing.com （压测时间30s）</span><br><span class="line">  8 threads and 200 connections （共8个测试线程，200个连接）</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">              （平均值） （标准差）（最大值）（正负一个标准差所占比例）</span><br><span class="line">    Latency    46.67ms  215.38ms   1.67s    95.59%</span><br><span class="line">    （延迟）</span><br><span class="line">    Req/Sec     7.91k     1.15k   10.26k    70.77%</span><br><span class="line">    （处理中的请求数）</span><br><span class="line">  Latency Distribution （延迟分布）</span><br><span class="line">     50%    2.93ms</span><br><span class="line">     75%    3.78ms</span><br><span class="line">     90%    4.73ms</span><br><span class="line">     99%    1.35s （99分位的延迟）</span><br><span class="line">  1790465 requests in 30.01s, 684.08MB read （30.01秒内共处理完成了1790465个请求，读取了684.08MB数据）</span><br><span class="line">Requests/sec:  59658.29 （平均每秒处理完成59658.29个请求）</span><br><span class="line">Transfer/sec:     22.79MB （平均每秒读取数据22.79MB）</span><br></pre></td></tr></table></figure><p>可以看到，wrk使用方便，结果清晰。并且因为非阻塞IO的使用，可以在普通的测试机上创建出大量的连接，从而达到较好的压测效果。</p><p>使用Lua脚本个性化wrk压测<br>以上两节安装并简单使用了wrk，但这种简单的压测可能不能满足我们的需求。比如我们可能需要使用POST METHOD跟服务器交互；可能需要为每一次请求使用不同的参数，以更好的模拟服务的实际使用场景等。wrk支持用户使用–script指定Lua脚本，来定制压测过程，满足个性化需求。</p><p>介绍wrk对Lua脚本的支持<br>wrk支持在三个阶段对压测进行个性化，分别是启动阶段、运行阶段和结束阶段。每个测试线程，都拥有独立的Lua运行环境。</p><p>启动阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function setup(thread)</span><br></pre></td></tr></table></figure><br>在脚本文件中实现setup方法，wrk就会在测试线程已经初始化但还没有启动的时候调用该方法。wrk会为每一个测试线程调用一次setup方法，并传入代表测试线程的对象thread作为参数。setup方法中可操作该thread对象，获取信息、存储信息、甚至关闭该线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread.addr             - get or set the thread&apos;s server address</span><br><span class="line">thread:get(name)        - get the value of a global in the thread&apos;s env</span><br><span class="line">thread:set(name, value) - set the value of a global in the thread&apos;s env</span><br><span class="line">thread:stop()           - stop the thread</span><br><span class="line">运行阶段</span><br><span class="line">function init(args)</span><br><span class="line">function delay()</span><br><span class="line">function request()</span><br><span class="line">function response(status, headers, body)</span><br></pre></td></tr></table></figure><p>init由测试线程调用，只会在进入运行阶段时，调用一次。支持从启动wrk的命令中，获取命令行参数； delay在每次发送request之前调用，如果需要delay，那么delay相应时间； request用来生成请求；每一次请求都会调用该方法，所以注意不要在该方法中做耗时的操作； reponse在每次收到一个响应时调用；为提升性能，如果没有定义该方法，那么wrk不会解析headers和body；</p><p>结束阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function done(summary, latency, requests)</span><br></pre></td></tr></table></figure><br>该方法在整个测试过程中只会调用一次，可从参数给定的对象中，获取压测结果，生成定制化的测试报告。</p><p>自定义脚本中可访问的变量和方法<br>变量：wrk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wrk = &#123;</span><br><span class="line">   scheme  = &quot;http&quot;,</span><br><span class="line">   host    = &quot;localhost&quot;,</span><br><span class="line">   port    = nil,</span><br><span class="line">   method  = &quot;GET&quot;,</span><br><span class="line">   path    = &quot;/&quot;,</span><br><span class="line">   headers = &#123;&#125;,</span><br><span class="line">   body    = nil,</span><br><span class="line">   thread  = &lt;userdata&gt;,</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>一个table类型的变量wrk，是全局变量，修改该table，会影响所有请求。</p><p>方法：wrk.fomat wrk.lookup wrk.connect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function wrk.format(method, path, headers, body)</span><br><span class="line"></span><br><span class="line">  wrk.format returns a HTTP request string containing the passed parameters</span><br><span class="line">  merged with values from the wrk table.</span><br><span class="line">  根据参数和全局变量wrk，生成一个HTTP rquest string。</span><br><span class="line"></span><br><span class="line">function wrk.lookup(host, service)</span><br><span class="line"></span><br><span class="line">  wrk.lookup returns a table containing all known addresses for the host</span><br><span class="line">  and service pair. This corresponds to the POSIX getaddrinfo() function.</span><br><span class="line">  给定host和service（port/well known service name），返回所有可用的服务器地址信息。</span><br><span class="line"></span><br><span class="line">function wrk.connect(addr)</span><br><span class="line"></span><br><span class="line">  wrk.connect returns true if the address can be connected to, otherwise</span><br><span class="line">  it returns false. The address must be one returned from wrk.lookup().</span><br><span class="line">  测试与给定的服务器地址信息是否可以成功创建连接</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>示例<br>使用POST METHOD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wrk.method = &quot;POST&quot;</span><br><span class="line">wrk.body   = &quot;foo=bar&amp;baz=quux&quot;</span><br><span class="line">wrk.headers[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;</span><br></pre></td></tr></table></figure><p>通过修改全局变量wrk，使得所有请求都使用POST方法，并指定了body和Content-Type头。</p><p>为每次request更换一个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request = function()</span><br><span class="line">   uid = math.random(1, 10000000)</span><br><span class="line">   path = &quot;/test?uid=&quot; .. uid</span><br><span class="line">   return wrk.format(nil, path)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>通过在request方法中随机生成1~10000000之间的uid，使得请求中的uid参数随机。</p><p>每次请求之前延迟10ms<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function delay()</span><br><span class="line">   return 10</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>每个线程要先进行认证，认证之后获取token以进行压测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">token = nil</span><br><span class="line">path  = &quot;/authenticate&quot;</span><br><span class="line"></span><br><span class="line">request = function()</span><br><span class="line">   return wrk.format(&quot;GET&quot;, path)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">response = function(status, headers, body)</span><br><span class="line">   if not token and status == 200 then</span><br><span class="line">      token = headers[&quot;X-Token&quot;]</span><br><span class="line">      path  = &quot;/resource&quot;</span><br><span class="line">      wrk.headers[&quot;X-Token&quot;] = token</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>在没有token的情况下，先访问/authenticate认证。认证成功后，读取token并替换path为/resource。</p><p>压测支持HTTP pipeline的服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">init = function(args)</span><br><span class="line">   local r = &#123;&#125;</span><br><span class="line">   r[1] = wrk.format(nil, &quot;/?foo&quot;)</span><br><span class="line">   r[2] = wrk.format(nil, &quot;/?bar&quot;)</span><br><span class="line">   r[3] = wrk.format(nil, &quot;/?baz&quot;)</span><br><span class="line"></span><br><span class="line">   req = table.concat(r)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">request = function()</span><br><span class="line">   return req</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>通过在init方法中将三个HTTP request请求拼接在一起，实现每次发送三个请求，以使用HTTP pipeline。</p><p>最后<br>源码非常简洁，简单读了读，很佩服wrk的作者。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>创建多个ssh-key</title>
      <link href="/2018/12/19/%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAssh-key/"/>
      <url>/2018/12/19/%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAssh-key/</url>
      
        <content type="html"><![CDATA[<p>生产环境下经常需要为同一台机器配置多个ssh-key并且在访问指定服务器时使用指定的key<br><a id="more"></a><br>首先简单了解一下ssh：</p><p>Secure Shell（安全外壳协议，简称 SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。多应用在远程登录服务器，git拉取与推送，在不是用密码登录的情况下可以通过创建一对ssh私钥与ssh公钥进行免密登录以及git操作。</p><p>创建第一个ssh-key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh                                 #首先先进入ssh目录下</span><br><span class="line">ssh-keygen -t rsa -C &quot;email@gmail.com&quot;    #创建第一个ssh-key</span><br></pre></td></tr></table></figure><p>之后会看见<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/Users/aamen/.ssh/id_rsa): test1   #给要创建的 ssh-key 命名</span><br><span class="line">Enter passphrase (empty for no passphrase):                             #指定密码（空为不指定）</span><br><span class="line">Enter same passphrase again:                                            #重复输入密码</span><br></pre></td></tr></table></figure><br>这就创建完成第一个ssh-key 并且在 ~/.ssh 目录下发现多了两个文件分别是 tes1 和 test1.pub</p><p>再次输入创建新的 ssh-key 并且命名为 test2</p><p>现在 ~/.ssh 目录下有4个文件 分别是 tes1 test1.pub 以及 tes2 和 test2.pub</p><p>然后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim config</span><br></pre></td></tr></table></figure><br>将里面内容修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host github                          # alias名称</span><br><span class="line">HostName github.com                  # host domain 或 ip</span><br><span class="line">Port port-number                     # host 的 SSH port 可不填 默认22</span><br><span class="line">PreferredAuthentications publickey   # 强制使用 Public Key 验证</span><br><span class="line">IdentitiesOnly yes                   # 使用指定的 key</span><br><span class="line">IdentityFile ~/.ssh/test1            # 指定 pem 或 pub 的 key 路径</span><br><span class="line">User username-on-remote-machine      # 登录 SSH 的 username 可不填</span><br></pre></td></tr></table></figure><br>保存并退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq!</span><br></pre></td></tr></table></figure></p><p>测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><br>成功后返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxx! You&apos;ve successfully authenticated, but GitHub does not # provide shell access.</span><br></pre></td></tr></table></figure><br>然后再次修改 config 并添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host gitlab                          # alias名称</span><br><span class="line">HostName gitlab.com                  # host domain 或 ip</span><br><span class="line">Port port-number                     # host 的 SSH port 可不填 默认22</span><br><span class="line">PreferredAuthentications publickey   # 强制使用 Public Key 验证</span><br><span class="line">IdentitiesOnly yes                   # 使用指定的 key</span><br><span class="line">IdentityFile ~/.ssh/test2            # 指定 pem 或 pub 的 key 路径</span><br><span class="line">User username-on-remote-machine      # 登录 SSH 的 username 可不填</span><br></pre></td></tr></table></figure><br>测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh -T git@gitlab.com</span><br><span class="line">Welcome to GitLab, @xxx!</span><br></pre></td></tr></table></figure><br>大功告成~</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker搭建php服务</title>
      <link href="/2018/12/07/nginx%E9%85%8D%E7%BD%AEphp/"/>
      <url>/2018/12/07/nginx%E9%85%8D%E7%BD%AEphp/</url>
      
        <content type="html"><![CDATA[<p>1.登录远端服务器并且下载docker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker</span><br></pre></td></tr></table></figure><br>下载完成后运行 docker info 如果输出docker信息则表示docker安装成功<br> <a id="more"></a><br>安装成功后，拉取nginx、php镜像并查看已有镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx      #拉取nginx镜像</span><br><span class="line">docker pull php:5.6    #拉取php5.6镜像</span><br><span class="line">docker images          #查看已有镜像</span><br></pre></td></tr></table></figure></p><p>镜像拉取成功后，开始构建容器并挂载nginx配置目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p nginx/www nginx/conf #创建nginx目录用来挂载容器www和conf目录</span><br></pre></td></tr></table></figure></p><ul><li>mkdir -p, –parents  可以是一个路径名称。此时若路径中的某些目录尚不存在, 加上此选项后, 系统将自动建立好那些尚不存在的目录, 即一次可以建立多个目录; </li></ul><p>创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#构建php容器</span><br><span class="line">docker run -d -p 9000:9000 -v $PWD/www:/usr/share/nginx/html --name myphpfpm php:5.6-fpm </span><br><span class="line">#构建Nginx容器</span><br><span class="line">docker run -d -p 8080:80 -v $PWD/www:/usr/share/nginx/html --name mynginx --link myphpfpm:phpfpm nginx </span><br><span class="line">docker ps -a      #查看所有已创建的容器 </span><br></pre></td></tr></table></figure><br>查看容器运行状态status，如果创建容器后容器自动退出，先删除容器，再重新用以下命令创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm [CONTAINER ID] #删除容器</span><br><span class="line">docker run -dit -p 9000:9000 -v $PWD/www:/usr/share/nginx/html --name myphpfpm php:5.6-fpm </span><br><span class="line">docker run -dit -p 8080:80 -v $PWD/www:/usr/share/nginx/html --name mynginx --link myphpfpm:phpfpm nginx</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><figcaption><span>docker run -it</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-i: 以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br></pre></td></tr></table></figure><p>创建完容器并且运行成功后配置nginx容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mynginx /bin/bash</span><br><span class="line">vim /etc/nginx/conf.d/default.conf #若无vi 先运行 apt-get update、 apt-get install vim 下载并安装vim</span><br></pre></td></tr></table></figure></p><p>docker exec [OPTIONS] CONTAINER COMMAND [ARG…]<br>-d : 分离模式: 在后台运行<br>-i : 即使没有附加也保持 STDIN 打开<br>-t : 分配一个伪终端</p><p>修改default.conf中php配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">   fastcgi_pass   phpfpm:9000;</span><br><span class="line">   fastcgi_index  index.php;</span><br><span class="line">   fastcgi_param  SCRIPT_FILENAME  /usr/share/nginx/html$fastcgi_script_name;</span><br><span class="line">   fastcgi_param  SCRIPT_NAME      $fastcgi_script_name;</span><br><span class="line">   include        fastcgi_params;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//重新加载nginx配置并生效后退出容器 </span><br><span class="line">//nginx -s reload</span><br><span class="line">//exit</span><br></pre></td></tr></table></figure><br>重启nginx并退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service nginx restart</span><br><span class="line">docker restart mynginx</span><br></pre></td></tr></table></figure><br>安装数据库扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec  -it myphpfpm /bin/bash</span><br><span class="line">docker-php-ext-install bcmath dba exif mysqli pdo_mysql sysvsem sysvshm </span><br></pre></td></tr></table></figure><br>安装redis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec  -it myphpfpm /bin/bash</span><br><span class="line">pecl install redis &amp;&amp; docker-php-ext-enable redis</span><br></pre></td></tr></table></figure><br>安装pecl扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Install PECL extensions</span><br><span class="line">$ apt-get install -y \</span><br><span class="line"></span><br><span class="line">    // for memcache</span><br><span class="line">    libmemcache-dev \</span><br><span class="line"></span><br><span class="line">    // for memcached</span><br><span class="line">    libmemcached-dev \</span><br><span class="line"></span><br><span class="line">    &amp;&amp; pecl install memcache &amp;&amp; docker-php-ext-enable memcache \</span><br><span class="line">    &amp;&amp; pecl install memcached &amp;&amp; docker-php-ext-enable memcached \</span><br><span class="line">    &amp;&amp; pecl install gearman &amp;&amp; docker-php-ext-enable gearman \</span><br><span class="line">    &amp;&amp; pecl install xdebug &amp;&amp; docker-php-ext-enable xdebug \</span><br><span class="line">    &amp;&amp; pecl install redis &amp;&amp; docker-php-ext-enable redis \</span><br><span class="line">    &amp;&amp; pecl install xhprof &amp;&amp; docker-php-ext-enable xhprof </span><br></pre></td></tr></table></figure></p><p>安装php x-cache 扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL &apos;https://xcache.lighttpd.net/pub/Releases/3.2.0/xcache-3.2.0.tar.gz&apos; -o xcache.tar.gz \</span><br><span class="line">     &amp;&amp; mkdir -p xcache \</span><br><span class="line">     &amp;&amp; tar -xf xcache.tar.gz -C xcache --strip-components=1 \</span><br><span class="line">     &amp;&amp; rm xcache.tar.gz \</span><br><span class="line">     &amp;&amp; ( \</span><br><span class="line">         cd xcache \</span><br><span class="line">         &amp;&amp; phpize \</span><br><span class="line">         &amp;&amp; ./configure --enable-xcache \</span><br><span class="line">         &amp;&amp; make -j$(nproc) \</span><br><span class="line">         &amp;&amp; make install \</span><br><span class="line">     ) \</span><br><span class="line">     &amp;&amp; rm -r xcache \</span><br><span class="line">     &amp;&amp; docker-php-ext-enable xcache</span><br></pre></td></tr></table></figure><br>安装完之后退出myphpfpm容器并重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart myphpfpm</span><br></pre></td></tr></table></figure></p><p>重启后查看phpinfo发现x-cache已工作</p><p>容器的保存、导出与导入</p><p>先将生成好的容器创建为镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker commit myphpfpm myphpfpm_img</span><br><span class="line">docker commit mynginx  mynginx_img</span><br></pre></td></tr></table></figure><br>保存指定镜像为tar文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images #查看生成好的镜像id</span><br><span class="line">docker save [IMAGE ID] &gt; xxx.tar</span><br></pre></td></tr></table></figure><br>保存成功之后 先让我们删除之前创建的所有容器以及镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -aq)</span><br><span class="line">docker rm $(docker ps -aq)</span><br><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><br>加载image<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; xxx.tar #之前生成的image压缩文件</span><br></pre></td></tr></table></figure><br>加载成功后标记本地镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker tag [IMAGE ID] xxx:1</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
