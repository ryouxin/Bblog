
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aamen</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="aamen,"> 
    <meta name="description" content="##位运算基础概念
1、原码一个正数，按照绝对值大小转换成二进制数，称为原码2、反码将二进制数按位取反，所得的新二进制数称为原二进制数的反码其实就是把原码中的0变为1,1变为0例如：0000 010,"> 
    <meta name="author" content="Aamen"> 
    <link rel="alternative" href="atom.xml" title="Aamen" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">java反射总结</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">java反射总结</h1>
        <div class="stuff">
            <span>十二月 10, 2019</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/java/">java</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/面试/">面试</a></li></ul>


        </div>
        <div class="content markdown">
            <p>什么是反射？<br>反射就是动态加载对象，并对对象进行剖析。在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能成为Java反射机制。<br>反射的基本操作<br>创建一个类，用于演示反射的基本操作，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package fs;</span><br><span class="line">public class Student &#123;</span><br><span class="line">	private long id;</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public long getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setId(long id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>获取类中的所有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">		Method[] methods = clz.getMethods();</span><br><span class="line">		for (Method method : methods) &#123;</span><br><span class="line">			System.out.println(&quot;方法名：&quot; + method.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;fs.Student&quot;)：初始化指定的类</span><br><span class="line">clz.getMethods()：获取类中所有的方法(包括其继承类的方法)</span><br></pre></td></tr></table></figure>
<p>如果只需要获取加载类中的方法，不要父类的方法，可以使用下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = clz.getDeclaredMethods();</span><br></pre></td></tr></table></figure><br>Method是方法类，可以获取方法相关的信息，除了我们上面的方法名称，我们还可以获取其他的一些信息，比如：</p>
<p>方法返回类型：method.getReturnType().getName()<br>方法修饰符：Modifier.toString(method.getModifiers())<br>方法参数信息： method.getParameters()<br>方法上的注解： method.getAnnotations()<br>等等…….</p>
<p>操作方法<br>除了可以获取Class中方法的信息，还可以通过反射来调用方法，接下来看看怎么调用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">	Student stu = (Student) clz.newInstance();</span><br><span class="line">	System.out.println(stu.getName());</span><br><span class="line">	Method method = clz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">	method.invoke(stu, &quot;猿天地&quot;);</span><br><span class="line">	System.out.println(stu.getName());</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>通过class的newInstance()方法构造一个Student对象，然后调用getName()方法，这个时候输出的是null,然后通过方法名获取到setName方法，通过invoke调用方法，传入参数，然后调用getName()方法可以看到输出的就是我们设置的值“猿天地”。<br>获取类中的所有属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">Field[] fields = clz.getFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">	System.out.println(&quot;属性名：&quot; + field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>clz.getFields()只能获取public的属性，包括父类的。<br>如果需要获取自己声明的各种字段，包括public，protected，private得用clz.getDeclaredFields()<br>Field是属性类，可以获取属性相关的信息，比如：</p>
<p>属性类型：field.getType().getName()<br>属性修饰符：Modifier.toString(field.getModifiers())<br>属性上的注解： field.getAnnotations()<br>等等…….</p>
<p>操作属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">	Student stu = (Student) clz.newInstance();</span><br><span class="line">	Field field = clz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">	field.setAccessible(true);</span><br><span class="line">	System.out.println(field.get(stu));</span><br><span class="line">	field.set(stu, &quot;猿天地&quot;);</span><br><span class="line">	System.out.println(field.get(stu));</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>通过clz.getDeclaredField(“name”);获取name属性，调用get方法获取属性的值，第一次肯定是没有值的，然后调用set方法设置值，最后再次获取就有值了，在get之前有field.setAccessible(true);这个代码，如果不加的话就会报下面的错误信息：<br>Class fs.Test can not access a member of class fs.Student with modifiers “private”<br>setAccessible(true);以取消Java的权限控制检查，让我们在用反射时可以访问访问私有变量<br>反射的优缺点？<br>优点</p>
<p>反射提高了程序的灵活性和扩展性,在底层框架中用的比较多，业务层面的开发过程中尽量少用。</p>
<p>缺点</p>
<p>性能不好<br>反射是一种解释操作,用于字段和方法接入时要远慢于直接代码，下面通过2段简单的代码来比较下执行的时间就可以体现出性能的问题</p>
<p>直接创建对象，调用方法设置值，然后获取值，时间在300ms左右<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">	Student stu = new Student();</span><br><span class="line">	stu.setName(&quot;猿天地&quot;);</span><br><span class="line">	System.out.println(stu.getName());</span><br><span class="line">&#125;</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br></pre></td></tr></table></figure><br>利用反射来实现上面的功能，时间在500ms左右，我是在我本机测试的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">	Class&lt;?&gt; clz = Class.forName(&quot;fs.Student&quot;);</span><br><span class="line">	Student stu = (Student) clz.newInstance();</span><br><span class="line">	Method method = clz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">	method.invoke(stu, &quot;猿天地&quot;);</span><br><span class="line">	System.out.println(stu.getName());</span><br><span class="line">&#125;</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br></pre></td></tr></table></figure></p>
<p>程序逻辑有影响</p>
<p>使用反射操作会模糊化程序的内部逻辑，从代码的维护角度来讲，我们更希望在源码中看到程序的逻辑，反射相当于绕过了源码的方式,因此会带来维护难度比较大的问题。<br>反射的使用场景有哪些？</p>
<p>实现RPC框架<br>实现ORM框架<br>拷贝属性值（BeanUtils.copyProperties）<br>……</p>
<p>实现RPC框架<br>RPC是远程过程调用的简称，广泛应用在大规模分布式应用中。提到RPC框架在我脑海里第一闪现的就是Dubbo,远程过程调用的实现原理简单无非就是当客户端调用的时候通过动态代理向服务提供方发送调用的信息（Netty通信），服务提供方收到后根据客户端需要调用的方法，调用本地方法，拿到结果组装返回。这里就涉及到动态方法的调用，反射也就可以排上用场了。<br>至于Dubbo中是怎么动态调用的我就不太清楚啦，没去研究过Dubbo的源码哈，我临时看了下，找到了2个相关的类JdkProxyFactory和JavassistProxyFactory。<br>JdkProxyFactory就是用的method.invoke(proxy, arguments);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class JdkProxyFactory extends AbstractProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object doInvoke(T proxy, String methodName,</span><br><span class="line">                                      Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">                                      Object[] arguments) throws Throwable &#123;</span><br><span class="line">                Method method = proxy.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">                return method.invoke(proxy, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavassistProxyFactory是用的Javassist框架来实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JavassistProxyFactory extends AbstractProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">        // TODO Wrapper cannot handle this scenario correctly: the classname contains &apos;$&apos;</span><br><span class="line">        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&apos;$&apos;) &lt; 0 ? proxy.getClass() : type);</span><br><span class="line">        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object doInvoke(T proxy, String methodName,</span><br><span class="line">                                      Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">                                      Object[] arguments) throws Throwable &#123;</span><br><span class="line">                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现ORM框架<br>关于ORM的概念本文就不做过多的介绍了，主要给大家介绍下如何用反射实现ORM的核心功能，我们以保持操作来进行讲解，也就是定义一个与数据库表对应的实体类，写一个save方法，传入我们实体类就可以将这个对象中的属性值存储到数据库中，变成一条数据。<br>还是以上面的Student来作为与表对应的实体类，下面我们看如何实现save方法中的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void save(Object data, Class&lt;?&gt; entityClass) throws Exception &#123;</span><br><span class="line">	String sql = &quot;insert into &#123;0&#125;(&#123;1&#125;) values(&#123;2&#125;)&quot;;</span><br><span class="line">	String tableName = entityClass.getSimpleName();</span><br><span class="line">		</span><br><span class="line">	List&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; fs = new ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;Object&gt; values = new ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">	Field[] fields = entityClass.getDeclaredFields();</span><br><span class="line">	for (Field field : fields) &#123;</span><br><span class="line">		names.add(field.getName());</span><br><span class="line">		fs.add(&quot;?&quot;);</span><br><span class="line">		field.setAccessible(true);</span><br><span class="line">		values.add(field.get(data));</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	String fieldStr = names.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">	String valueStr = fs.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">	System.err.println(MessageFormat.format(sql, tableName, fieldStr, valueStr));</span><br><span class="line">	values.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		Student stu = new Student();</span><br><span class="line">		stu.setId(1);</span><br><span class="line">		stu.setName(&quot;猿天地&quot;);</span><br><span class="line">		save(stu, Student.class);</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行main方法，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into Student(id,name) values(?,?)</span><br></pre></td></tr></table></figure><br>当然我上面只是最简单的代码，考虑也没那么全面，为的只是让大家熟悉反射的使用方式和场景，接下来我们再配合注解做一个小小的优化，注解不熟的同学可以参考我的这篇文章：《注解面试题-请了解下》<br>优化2点，定义一个TableName注解，用于描述表的信息，上面我们是直接用的类名作为表名，实际使用中很有可能表名是stu_info这样的 ，还有就是定义一个Field用于描述字段的信息，原理同上。<br>定义TableName注解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line">/**</span><br><span class="line"> * 表名</span><br><span class="line"> * @author yinjihuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface TableName &#123;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 表名</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">定义Field注解：</span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line">/**</span><br><span class="line"> * 字段名</span><br><span class="line"> * @author yinjihuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123; ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE &#125;)</span><br><span class="line">public @interface Field &#123;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 字段名称</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	String value();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>修改实体类，增加注解的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@TableName(&quot;stu_info&quot;)</span><br><span class="line">public class Student &#123;</span><br><span class="line">	</span><br><span class="line">	private long id;</span><br><span class="line">	</span><br><span class="line">	@Field(&quot;stu_name&quot;)</span><br><span class="line">	private String name;</span><br><span class="line">	</span><br><span class="line">	public long getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setId(long id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>save方法中就需要考虑到有注解的情况，修改代码，增加获取注解中值的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void save(Object data, Class&lt;?&gt; entityClass) throws Exception &#123;</span><br><span class="line">	String sql = &quot;insert into &#123;0&#125;(&#123;1&#125;) values(&#123;2&#125;)&quot;;</span><br><span class="line">	String tableName = entityClass.getSimpleName();</span><br><span class="line">	if (entityClass.isAnnotationPresent(TableName.class)) &#123;</span><br><span class="line">		tableName = entityClass.getAnnotation(TableName.class).value();</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; fs = new ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;Object&gt; values = new ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">	Field[] fields = entityClass.getDeclaredFields();</span><br><span class="line">	for (Field field : fields) &#123;</span><br><span class="line">		String fieldName = field.getName();</span><br><span class="line">		if (field.isAnnotationPresent(fs.Field.class)) &#123;</span><br><span class="line">			fieldName = field.getAnnotation(fs.Field.class).value();</span><br><span class="line">		&#125;</span><br><span class="line">		names.add(fieldName);</span><br><span class="line">		fs.add(&quot;?&quot;);</span><br><span class="line">		field.setAccessible(true);</span><br><span class="line">		values.add(field.get(data));</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	String fieldStr = names.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">	String valueStr = fs.stream().collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">	System.err.println(MessageFormat.format(sql, tableName, fieldStr, valueStr));</span><br><span class="line">	values.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通上面的修改，如果有注解的情况下以注解中的值为主，没有的话就用Class中的。<br>执行main方法，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into stu_info(id,stu_name) values(?,?)</span><br></pre></td></tr></table></figure></p>
<p>更完整的反射实现的ORM可以参考我的框架：<a href="https://github.com/yinjihuan/smjdbctemplate" target="_blank" rel="noopener">https://github.com/yinjihuan/smjdbctemplate</a><br>拷贝属性值（BeanUtils.copyProperties）<br>在开发过程中，我们会遇到各种bean之间的转换，比如用ORM框架查询出来的数据，对应的bean,需要转换成Dto返回给调用方，这个时候就需要进行bean的转换了，下面通过简单的伪代码来讲解下：<br>Student stu = dao.get();<br>StudentDto dto = new StudentDto();<br>dto.setName(stu.getName());<br>dto.setXXX(stu.getXXX());<br>dto.set……<br>return dto;<br>如果属性多的话，光写set方法就要写很多行，有没有优雅的方式呢？<br>这个时候我们可以用Spring中的BeanUtils.copyProperties来实现上面的需求，只需要一行代码即可，关于BeanUtils.copyProperties的详细使用不做过多讲解：<br>Student stu = dao.get();<br>StudentDto dto = new StudentDto();<br>BeanUtils.copyProperties(stu, dto);<br>这个功能就是反射的功劳了，我们可以通过源码来验证下是否是通过反射来实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private static void copyProperties(Object source, Object target, Class&lt;?&gt; editable, String... ignoreProperties)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(source, &quot;Source must not be null&quot;);</span><br><span class="line">		Assert.notNull(target, &quot;Target must not be null&quot;);</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; actualEditable = target.getClass();</span><br><span class="line">		if (editable != null) &#123;</span><br><span class="line">			if (!editable.isInstance(target)) &#123;</span><br><span class="line">				throw new IllegalArgumentException(&quot;Target class [&quot; + target.getClass().getName() +</span><br><span class="line">						&quot;] not assignable to Editable class [&quot; + editable.getName() + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			actualEditable = editable;</span><br><span class="line">		&#125;</span><br><span class="line">		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);</span><br><span class="line">		List&lt;String&gt; ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null);</span><br><span class="line"></span><br><span class="line">		for (PropertyDescriptor targetPd : targetPds) &#123;</span><br><span class="line">			Method writeMethod = targetPd.getWriteMethod();</span><br><span class="line">			if (writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) &#123;</span><br><span class="line">				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());</span><br><span class="line">				if (sourcePd != null) &#123;</span><br><span class="line">					Method readMethod = sourcePd.getReadMethod();</span><br><span class="line">					if (readMethod != null &amp;&amp;</span><br><span class="line">							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) &#123;</span><br><span class="line">						try &#123;</span><br><span class="line">							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">								readMethod.setAccessible(true);</span><br><span class="line">							&#125;</span><br><span class="line">							Object value = readMethod.invoke(source);</span><br><span class="line">							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">								writeMethod.setAccessible(true);</span><br><span class="line">							&#125;</span><br><span class="line">							writeMethod.invoke(target, value);</span><br><span class="line">						&#125;</span><br><span class="line">						catch (Throwable ex) &#123;</span><br><span class="line">							throw new FatalBeanException(</span><br><span class="line">									&quot;Could not copy property &apos;&quot; + targetPd.getName() + &quot;&apos; from source to target&quot;, ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码不做过多解释，我们看最关键的2行代码，第一行是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object value = readMethod.invoke(source);</span><br></pre></td></tr></table></figure><br>通过调用读的方法将source中的值读取出来<br>第二行关键的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeMethod.invoke(target, value);</span><br></pre></td></tr></table></figure><br>通过调用写的方法进行复制到target中。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li>
                    
                        <li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="dd9478fe9b45c0677efd" data-cs="8dd7f2038439badc74850b24f0f837561a6a8765" data-r="Bblog" data-o="ryouxin" data-a="ryouxin" data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-131509355-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


</html>