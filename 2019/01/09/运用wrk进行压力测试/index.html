
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aamen</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="aamen,"> 
    <meta name="description" content="创建一个springboot maven工程，在工程内新创建3个spring boot model
123api     #定义接口类service #接口的实现类 dubbo的服务提供者web  ,"> 
    <meta name="author" content="Aamen"> 
    <link rel="alternative" href="atom.xml" title="Aamen" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">运用wrk进行压力测试</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">运用wrk进行压力测试</h1>
        <div class="stuff">
            <span>一月 09, 2019</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/linux/">linux</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/运维/">运维</a></li></ul>


        </div>
        <div class="content markdown">
            <p>用过了很多压测工具，却一直没找到中意的那款。最近试了wrk感觉不错，写下这份使用指南给自己备忘用，如果能帮到你，那也很好。<br><a id="more"></a><br>安装<br>wrk支持大多数类UNIX系统，不支持windows。需要操作系统支持LuaJIT和OpenSSL，不过不用担心，大多数类Unix系统都支持。安装wrk非常简单，只要从github上下载wrk源码，在项目路径下执行make命令即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg/wrk</span><br><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure><br>make之后，会在项目路径下生成可执行文件wrk，随后就可以用其进行HTTP压测了。可以把这个可执行文件拷贝到某个已在path中的路径，比如/usr/local/bin，这样就可以在任何路径直接使用wrk了。</p>
<p>默认情况下wrk会使用自带的LuaJIT和OpenSSL，如果你想使用系统已安装的版本，可以使用WITH_LUAJIT和WITH_OPENSSL这两个选项来指定它们的路径。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make WITH_LUAJIT=/usr WITH_OPENSSL=/usr</span><br></pre></td></tr></table></figure><br>基本使用<br>命令行敲下wrk，可以看到使用帮助<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Usage: wrk &lt;options&gt; &lt;url&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  Connections to keep open   </span><br><span class="line">    -d, --duration    &lt;T&gt;  Duration of test           </span><br><span class="line">    -t, --threads     &lt;N&gt;  Number of threads to use   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  Load Lua script file       </span><br><span class="line">    -H, --header      &lt;H&gt;  Add header to request      </span><br><span class="line">        --latency          Print latency statistics   </span><br><span class="line">        --timeout     &lt;T&gt;  Socket/request timeout     </span><br><span class="line">    -v, --version          Print version details      </span><br><span class="line">                                                      </span><br><span class="line">  Numeric arguments may include a SI unit (1k, 1M, 1G)</span><br><span class="line">  Time arguments may include a time unit (2s, 2m, 2h)</span><br></pre></td></tr></table></figure><br>简单翻成中文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  跟服务器建立并保持的TCP连接数量  </span><br><span class="line">    -d, --duration    &lt;T&gt;  压测时间           </span><br><span class="line">    -t, --threads     &lt;N&gt;  使用多少个线程进行压测   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  指定Lua脚本路径       </span><br><span class="line">    -H, --header      &lt;H&gt;  为每一个HTTP请求添加HTTP头      </span><br><span class="line">        --latency          在压测结束后，打印延迟统计信息   </span><br><span class="line">        --timeout     &lt;T&gt;  超时时间     </span><br><span class="line">    -v, --version          打印正在使用的wrk的详细版本信息</span><br><span class="line">                                                      </span><br><span class="line">  &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)</span><br><span class="line">  &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)</span><br></pre></td></tr></table></figure><br>看下版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrk -v</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">wrk 4.0.2 [epoll] Copyright (C) 2012 Will Glozer</span><br></pre></td></tr></table></figure><br>看到是4.0.2版本的wrk，使用了epoll。这意味着我们可以用少量的线程来跟被测服务创建大量连接，进行压测。</p>
<p>做一次简单压测，分析下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wrk -t8 -c200 -d30s --latency  &quot;http://www.bing.com&quot;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Running 30s test @ http://www.bing.com</span><br><span class="line">  8 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency    46.67ms  215.38ms   1.67s    95.59%</span><br><span class="line">    Req/Sec     7.91k     1.15k   10.26k    70.77%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    2.93ms</span><br><span class="line">     75%    3.78ms</span><br><span class="line">     90%    4.73ms</span><br><span class="line">     99%    1.35s </span><br><span class="line">  1790465 requests in 30.01s, 684.08MB read</span><br><span class="line">Requests/sec:  59658.29</span><br><span class="line">Transfer/sec:     22.79MB</span><br></pre></td></tr></table></figure><br>以上使用8个线程200个连接，对bing首页进行了30秒的压测，并要求在压测结果中输出响应延迟信息。以下对压测结果进行简单注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Running 30s test @ http://www.bing.com （压测时间30s）</span><br><span class="line">  8 threads and 200 connections （共8个测试线程，200个连接）</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">              （平均值） （标准差）（最大值）（正负一个标准差所占比例）</span><br><span class="line">    Latency    46.67ms  215.38ms   1.67s    95.59%</span><br><span class="line">    （延迟）</span><br><span class="line">    Req/Sec     7.91k     1.15k   10.26k    70.77%</span><br><span class="line">    （处理中的请求数）</span><br><span class="line">  Latency Distribution （延迟分布）</span><br><span class="line">     50%    2.93ms</span><br><span class="line">     75%    3.78ms</span><br><span class="line">     90%    4.73ms</span><br><span class="line">     99%    1.35s （99分位的延迟）</span><br><span class="line">  1790465 requests in 30.01s, 684.08MB read （30.01秒内共处理完成了1790465个请求，读取了684.08MB数据）</span><br><span class="line">Requests/sec:  59658.29 （平均每秒处理完成59658.29个请求）</span><br><span class="line">Transfer/sec:     22.79MB （平均每秒读取数据22.79MB）</span><br></pre></td></tr></table></figure>
<p>可以看到，wrk使用方便，结果清晰。并且因为非阻塞IO的使用，可以在普通的测试机上创建出大量的连接，从而达到较好的压测效果。</p>
<p>使用Lua脚本个性化wrk压测<br>以上两节安装并简单使用了wrk，但这种简单的压测可能不能满足我们的需求。比如我们可能需要使用POST METHOD跟服务器交互；可能需要为每一次请求使用不同的参数，以更好的模拟服务的实际使用场景等。wrk支持用户使用–script指定Lua脚本，来定制压测过程，满足个性化需求。</p>
<p>介绍wrk对Lua脚本的支持<br>wrk支持在三个阶段对压测进行个性化，分别是启动阶段、运行阶段和结束阶段。每个测试线程，都拥有独立的Lua运行环境。</p>
<p>启动阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function setup(thread)</span><br></pre></td></tr></table></figure><br>在脚本文件中实现setup方法，wrk就会在测试线程已经初始化但还没有启动的时候调用该方法。wrk会为每一个测试线程调用一次setup方法，并传入代表测试线程的对象thread作为参数。setup方法中可操作该thread对象，获取信息、存储信息、甚至关闭该线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread.addr             - get or set the thread&apos;s server address</span><br><span class="line">thread:get(name)        - get the value of a global in the thread&apos;s env</span><br><span class="line">thread:set(name, value) - set the value of a global in the thread&apos;s env</span><br><span class="line">thread:stop()           - stop the thread</span><br><span class="line">运行阶段</span><br><span class="line">function init(args)</span><br><span class="line">function delay()</span><br><span class="line">function request()</span><br><span class="line">function response(status, headers, body)</span><br></pre></td></tr></table></figure>
<p>init由测试线程调用，只会在进入运行阶段时，调用一次。支持从启动wrk的命令中，获取命令行参数； delay在每次发送request之前调用，如果需要delay，那么delay相应时间； request用来生成请求；每一次请求都会调用该方法，所以注意不要在该方法中做耗时的操作； reponse在每次收到一个响应时调用；为提升性能，如果没有定义该方法，那么wrk不会解析headers和body；</p>
<p>结束阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function done(summary, latency, requests)</span><br></pre></td></tr></table></figure><br>该方法在整个测试过程中只会调用一次，可从参数给定的对象中，获取压测结果，生成定制化的测试报告。</p>
<p>自定义脚本中可访问的变量和方法<br>变量：wrk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wrk = &#123;</span><br><span class="line">   scheme  = &quot;http&quot;,</span><br><span class="line">   host    = &quot;localhost&quot;,</span><br><span class="line">   port    = nil,</span><br><span class="line">   method  = &quot;GET&quot;,</span><br><span class="line">   path    = &quot;/&quot;,</span><br><span class="line">   headers = &#123;&#125;,</span><br><span class="line">   body    = nil,</span><br><span class="line">   thread  = &lt;userdata&gt;,</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>一个table类型的变量wrk，是全局变量，修改该table，会影响所有请求。</p>
<p>方法：wrk.fomat wrk.lookup wrk.connect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function wrk.format(method, path, headers, body)</span><br><span class="line"></span><br><span class="line">  wrk.format returns a HTTP request string containing the passed parameters</span><br><span class="line">  merged with values from the wrk table.</span><br><span class="line">  根据参数和全局变量wrk，生成一个HTTP rquest string。</span><br><span class="line"></span><br><span class="line">function wrk.lookup(host, service)</span><br><span class="line"></span><br><span class="line">  wrk.lookup returns a table containing all known addresses for the host</span><br><span class="line">  and service pair. This corresponds to the POSIX getaddrinfo() function.</span><br><span class="line">  给定host和service（port/well known service name），返回所有可用的服务器地址信息。</span><br><span class="line"></span><br><span class="line">function wrk.connect(addr)</span><br><span class="line"></span><br><span class="line">  wrk.connect returns true if the address can be connected to, otherwise</span><br><span class="line">  it returns false. The address must be one returned from wrk.lookup().</span><br><span class="line">  测试与给定的服务器地址信息是否可以成功创建连接</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>示例<br>使用POST METHOD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wrk.method = &quot;POST&quot;</span><br><span class="line">wrk.body   = &quot;foo=bar&amp;baz=quux&quot;</span><br><span class="line">wrk.headers[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;</span><br></pre></td></tr></table></figure>
<p>通过修改全局变量wrk，使得所有请求都使用POST方法，并指定了body和Content-Type头。</p>
<p>为每次request更换一个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request = function()</span><br><span class="line">   uid = math.random(1, 10000000)</span><br><span class="line">   path = &quot;/test?uid=&quot; .. uid</span><br><span class="line">   return wrk.format(nil, path)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>通过在request方法中随机生成1~10000000之间的uid，使得请求中的uid参数随机。</p>
<p>每次请求之前延迟10ms<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function delay()</span><br><span class="line">   return 10</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>每个线程要先进行认证，认证之后获取token以进行压测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">token = nil</span><br><span class="line">path  = &quot;/authenticate&quot;</span><br><span class="line"></span><br><span class="line">request = function()</span><br><span class="line">   return wrk.format(&quot;GET&quot;, path)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">response = function(status, headers, body)</span><br><span class="line">   if not token and status == 200 then</span><br><span class="line">      token = headers[&quot;X-Token&quot;]</span><br><span class="line">      path  = &quot;/resource&quot;</span><br><span class="line">      wrk.headers[&quot;X-Token&quot;] = token</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>在没有token的情况下，先访问/authenticate认证。认证成功后，读取token并替换path为/resource。</p>
<p>压测支持HTTP pipeline的服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">init = function(args)</span><br><span class="line">   local r = &#123;&#125;</span><br><span class="line">   r[1] = wrk.format(nil, &quot;/?foo&quot;)</span><br><span class="line">   r[2] = wrk.format(nil, &quot;/?bar&quot;)</span><br><span class="line">   r[3] = wrk.format(nil, &quot;/?baz&quot;)</span><br><span class="line"></span><br><span class="line">   req = table.concat(r)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">request = function()</span><br><span class="line">   return req</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>通过在init方法中将三个HTTP request请求拼接在一起，实现每次发送三个请求，以使用HTTP pipeline。</p>
<p>最后<br>源码非常简洁，简单读了读，很佩服wrk的作者。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li>
                    
                        <li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="dd9478fe9b45c0677efd" data-cs="8dd7f2038439badc74850b24f0f837561a6a8765" data-r="Bblog" data-o="ryouxin" data-a="ryouxin" data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-131509355-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


</html>